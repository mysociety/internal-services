#!/usr/bin/perl -w
#
# process_codepoint_ni:
# Read CodePoint postcodes, coordinates and ONS ward codes, and use them to
# generate a mapping from postcodes to electoral geography.
#
# Call with three arguments:
#   - name of MaPit Postgresql database;
#   - CSV file generated from the ward to constituency mapping in SNAC;
#   - CSV file of postcodes and other data from CodePoint.
#
# All NI postcodes begin BT, so the appropriate file from the CodePoint
# distribution is BT.CSV. The mapping from ward codes to constituencies is
# available in the ONS SNAC ("Standard Names and Codes") product, from
#   http://www.statistics.gov.uk/geography/snac.asp
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_codepoint_ni,v 1.5 2004-12-07 00:14:43 francis Exp $';

use strict;

use DBI;
use IO::File;
use Text::CSV_XS;

use Common;

# Text::CSV excludes characters outside the ASCII range from CSV values (bug
# reported two years ago, never fixed). Text::CSV_XS also has this behaviour
# by default, but offers options for a slightly less inept behaviour.
my $c = new Text::CSV_XS({ binary => 1 });

die "arguments are Postgres database name, ONS codes CSV file, and CodePoint CSV file" unless (@ARGV == 3);

my ($dbname, $onscodesfile, $codepointfile) = @ARGV;
my $dbh = connect_to_mapit_database($dbname);

# Special case: create a Euro-region.
my $euro_area_id = get_area_id($dbh, 'Northern Ireland', 'F', 'EUR', undef, undef, undef);
    # NIA etc.?
country($dbh, $euro_area_id, 'N');

my %name;
my %ward_to_const;
my %ward_to_district;

my (%aid, %wid, %cid, %eid);

print STDERR "reading ward/constituency codes... ";
foreach (read_csv_file($onscodesfile, 1)) {
    # Fields are:
    #   ONS constituency code
    #                    name
    #   ONS ward code
    #            name
    #   ONS LA/UA code
    #             name
    my ($ccode, $cname, $wcode, $wname, $acode, $aname) = @$_;

    # load Northern Ireland only
    next if ($wcode !~ m/^95/);

    die "undefined constituency code in '$_'" if (!defined($ccode));
    die "undefined ward code in '$_'" if (!defined($wcode));
    die "undefined LA/UA code in '$_'" if (!defined($acode));
    
    $wcode =~ s/ //g;

    if (!exists($name{$acode})) {
        country($dbh, $aid{$acode} = get_area_id($dbh, $aname, 'S', 'LGD', $acode, undef, undef), 'N');
    }

    if (!exists($name{$wcode})) {
        country($dbh, $wid{$wcode} = get_area_id($dbh, $wname, 'S', 'LGW', $wcode, undef, undef), 'N');
        $dbh->do(q#update area set parent_area_id = (select id from area where ons_code = ?) where id = ?#, {}, $acode, $wid{$wcode});
    }

    if (!exists($name{$ccode})) {
        country($dbh, $cid{$ccode} = get_area_id($dbh, $wname, 'S', 'WMC', $ccode, undef, undef), 'N');
        # Northern Ireland Assembly electoral areas are coterminous with
        # Westminster constituencies; note that they have no identifying codes
        # at all, but in memory index them by the ONS code of the coincident
        # constituency.
        country($dbh, $eid{$ccode} = get_area_id($dbh, $wname, 'S', 'NIE', undef, undef, undef), 'N');
    }

    $name{$ccode} ||= $cname;
    $name{$wcode} ||= $wname;
    $name{$acode} ||= $aname;

    $ward_to_const{$wcode} = $ccode;
    $ward_to_district{$wcode} = $acode;
}
print STDERR "done.\n";

my %unused = map { $_ => 1 } grep(/^95/, keys %ward_to_const);

my @postcode;
my @incomplete;
my $nopos = 0;
my %cache;

my $f = new IO::File($codepointfile) or die "$codepointfile: $!";
while (defined($_ = $f->getline())) {
    chomp2($_);
    $c->parse($_) or die "unable to parse '$_'";
    # Fields:
    #   0       postcode
    #   1       accuracy code
    #   11      easting
    #   12      northing
    #   16..18  ward code
    my @f = $c->fields();

    my $pc = $f[0];
    $pc =~ s/ //g;
    my ($E, $N) = @f[10 .. 11];
    my $ward = join('', @f[15 .. 17]);
    $ward =~ s/ //g;

    # Our current (20041122) copy of Codepoint miscodes 95X (Ards DC) as 955. I
    # checked this by comparing plots of postcode locations in the various
    # wards with the maps prepared by NISRA NINIS at,
    #   http://www.ninis.nisra.gov.uk/mapxtreme/MapCatalogue.asp
    # Note that those maps (a) do not work in web browsers other than Microsoft
    # "Internet Explorer"; (b) are annotated with what appear to be an obsolete
    # series of ward codes beginning 95BB; these do not appear in the current
    # ONS indices.
    $ward =~ s#^955#95X#;

    # Skip postcodes which have no positional information (PQ of 90); these are
    # mostly PO boxes and things.
    if ($f[1] == 90) {
        ++$nopos;
        next;
    }

    # Some postcodes do not have a full ward code.
    if (length($ward) != 5) {
        push(@incomplete, [$pc, $E, $N, $ward]);
        next;
    }
    
    push(@postcode, [$pc, $E, $N, $ward]);
    $cache{"$E,$N"} = $ward;

    if (!exists($name{$ward})) {
        die "no ward for code '$ward'\n";
    } elsif (!exists($ward_to_const{$ward})) {
        die "ward '$ward' does not lie in any constituency\n";
    } elsif (!exists($ward_to_district{$ward})) {
        die "ward '$ward' does not lie in any district\n";
    }

    delete($unused{$ward});
}
die "$codepointfile: $!" if ($f->error());
$f->close();

printf STDERR "got %d good, %d bad PCs and %d with no positional information\n", scalar(@postcode), scalar(@incomplete), $nopos;
printf STDERR "%d NI wards contained no postcodes\n", scalar(keys %unused);

# Now attempt to guess the ward in which postcodes with incomplete ward codes
# lie.

@postcode = sort { $a->[1] <=> $b->[1] } @postcode;

my @reassigned;

print STDERR "trying to guess wards for postcodes with incomplete codes...\n";
foreach (@incomplete) {
    my ($pc, $E, $N, $ward) = @$_;

    if (exists($cache{"$E,$N"})) {
        # Have a postcode for this exact location already.
        push(@reassigned, [$pc, $E, $N, $cache{"$E,$N"}]);
        next;
    }

    my $radius = 10;
    my @nearby; # Nearby postcodes
    my @possibles;

    while (@nearby == 0) {
        @nearby = ( );

#        print STDERR "\r$pc  ";
        
        my ($il, $ih) = (0, $#postcode);
        while ($ih > $il + 1) {
            my $i = int(($il + $ih) / 2);
            if ($postcode[$i]->[1] < $E - $radius) {
                $il = $i;
            } elsif ($postcode[$i]->[1] > $E - $radius) {
                $ih = $i;
            } else {
                $il = $i;
                last;
            }
        }

        while ($il < @postcode && $postcode[$il]->[1] <= $E + $radius) {
            my ($dE, $dN) = ($E - $postcode[$il]->[1], $N - $postcode[$il]->[2]);
            if ($postcode[$il]->[3] =~ m#^95# and sqrt($dE**2 + $dN**2) < $radius) {
                push(@nearby, [@{$postcode[$il]}, sqrt($dE**2 + $dN**2)]);
            }
            ++$il;
        }

        if (@nearby > 0) {
            my %p = map { $_->[3] => 1 } @nearby;
            @possibles = sort keys %p;
            if (@possibles > 1) {
#                print "\r$pc possible wards are: ", join(" ", @possibles), "\n";
#                print "radius = $radius\n";
#                print join("\n", map { sprintf("%s %s %f", $_->[0], $_->[3], $_->[4]) } sort { $a->[4] <=> $b->[4] } @nearby), "\n";
            } elsif (@possibles == 1) {
                push(@reassigned, [$pc, $E, $N, $possibles[0]]);
            }
        }

        $radius *= 1.05;
    }
}

printf STDERR "reassigned %d postcodes on a nearest-neighbour basis; %d bad remain\n", scalar(@reassigned), scalar(@incomplete) - scalar(@reassigned);

push(@postcode, @reassigned);

# Now @postcode contains all the postcodes for which we have ward codes.
print STDERR "writing postcodes into database...\n";
my $n = 0;
foreach (@postcode) {
    ++$n;
    printf STDERR "\r%d/%d", $n, scalar(@postcode) if (0 == ($n % 100));
    my ($pc, $E, $N, $ward) = @$_;

    my $pcid = get_postcode_id($dbh, $pc, $E, $N);
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $wid{$ward});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $cid{$ward_to_const{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $eid{$ward_to_const{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $aid{$ward_to_district{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $euro_area_id);
}
printf STDERR "\r%d/%d\n", $n, scalar(@postcode);
print STDERR "committing changes... ";
$dbh->commit();
$dbh->disconnect();
print STDERR "done.\n";

exit(0);
