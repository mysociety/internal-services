#!/usr/bin/perl -w -I../../perllib
#
# process_codepoint_ni:
# Read CodePoint postcodes, coordinates and ONS ward codes, and use them to
# generate a mapping from postcodes to electoral geography in Northern Ireland.
#
# Call with three arguments:
#   - CSV file generated from the ward to constituency mapping in SNAC;
#   - CSV file of ward to electoral area mapping from the District Electoral
#     Areas (Northern Ireland) Order 1993, or later;
#   - CSV file of postcodes and other data from CodePoint.
#
# All NI postcodes begin BT, so the appropriate file from the CodePoint
# distribution is BT.CSV. The mapping from ward codes to constituencies is
# available in the ONS SNAC ("Standard Names and Codes") product, from
#   http://www.statistics.gov.uk/geography/snac.asp
# snac-2003-cons2ward.csv is a version of this converted to CSV.
#
# For example run like this:
# ./process_codepoint_ni snac-2003-cons2ward.csv ni-electoral-areas.csv ~/toobig/geodata-mysociety/codepoint-2004-11/bt.csv
#
# If you want to undo what this script puts into MaPit so you can run it
# again, you might find these commands helpful:
#   delete from postcode_area where (select postcode from postcode where postcode_id = id) like 'BT%';
#   delete from postcode where postcode like 'BT%';
#   delete from area_name where (select country from area where area_id = id) = 'N';
#   delete from area where country = 'N';
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/

my $rcsid = ''; $rcsid .= '$Id: process_codepoint_ni,v 1.20 2007-05-08 20:17:26 matthew Exp $';

use strict;

use Data::Dumper;
use DBI;
use IO::File;
use Text::CSV_XS;

use Common;

# Text::CSV excludes characters outside the ASCII range from CSV values (bug
# reported two years ago, never fixed). Text::CSV_XS also has this behaviour
# by default, but offers options for a slightly less inept behaviour.
my $c = new Text::CSV_XS({ binary => 1 });

die "arguments are ONS codes CSV file, NI electoral areas CSV file, and CodePoint CSV file" unless (@ARGV == 3);

my ($onscodesfile, $nieasfile, $codepointfile) = @ARGV;
my $dbh = connect_to_mapit_database();

# Special case: create a Euro-region if none exists.
my $euro_area_id = $dbh->selectrow_array("
                select id from area, area_name
                    where area.id = area_name.area_id
                      and country = 'N'
                      and type = 'EUR'
                      and name_type = 'M'
                      and name = 'Northern Ireland'
                      and ? >= generation_low
                      and ? <= generation_high", {},
                current_generation($dbh), current_generation($dbh));
if (defined($euro_area_id)) {
    $dbh->do('update area set generation_high = ? where id = ?', {}, new_generation($dbh), $euro_area_id);
    print STDERR "using existing area ID #$euro_area_id for EUR 'Northern Ireland'\n";
} else {
    $euro_area_id = get_area_id($dbh, 'Northern Ireland', 'M', 'EUR', undef, undef, undef);
    country($dbh, $euro_area_id, 'N');
}

# %name
# Name of anything with an ONS code.
my %name;

# %ward_to_const
# ONS ward code to constituency ONS code.
my %ward_to_const;

# %ward_to_district
# ONS ward code to district ONS code.
my %ward_to_district;

# %aid, %eaid, %cid, %eid
# ONS district/ward/constituency code to area ID of district, district
# electoral area, constituency and assembly electoral area.
my (%aid, %eaid, %cid, %eid);

# %wardname_to_ea
# Map from {district}->{ward} to ID of electoral area.
my %wardname_to_ea;

print STDERR "reading mapping from wards to Electoral Areas... ";
my ($district, $electoralarea);
my %e;
foreach (read_csv_file($nieasfile, 1)) {
    my ($d, $ea, $w) = @$_;
    $d = $district if ($d eq '');;
    $district = $d;
    die "no district" unless (defined($d));

    $ea = $electoralarea if ($ea eq '');
    $electoralarea = $ea;
    die "no electoral area" unless (defined($ea));

    if (!exists($e{$ea})) {
        # See if there's already an electoral area having this name.
        my $id = $dbh->selectrow_array("
                        select id from area, area_name
                            where area.id = area_name.area_id
                              and country = 'N'
                              and type = 'LGE'
                              and name_type = 'L'
                              and name = ?
                              and ? >= generation_low
                              and ? <= generation_high", {},
                        $ea, current_generation($dbh), current_generation($dbh));
        if (defined($id)) {
            print STDERR "using existing area ID #$id for LGE '$ea'\n";
            $dbh->do('update area set generation_high = ? where id = ?', {}, new_generation($dbh), $id);
            $e{$ea} = $id;
        } else {
            country($dbh, $e{$ea} = get_area_id($dbh, $ea, 'L', 'LGE', undef, undef, undef), 'N');
        }
    }
    $wardname_to_ea{$d}->{$w} = $e{$ea};
}
print STDERR "done.\n";

print STDERR "reading ward/constituency codes... ";
foreach (read_csv_file($onscodesfile, 1)) {
    # Fields are:
    #   ONS constituency code
    #                    name
    #   ONS ward code
    #            name
    #   ONS LA/UA code
    #             name
    my ($ccode, $cname, $wcode, $wname, $acode, $aname) = @$_;
    # load Northern Ireland only
    next if ($wcode !~ m/^95/);

#    $wcode =~ s/ //;

    die "no LA/UA '$aname' in electoral areas map" unless (exists($wardname_to_ea{$aname}));
    warn "no ward '$wname' in LA/UA '$aname' in electoral areas map" unless (exists($wardname_to_ea{$aname}->{$wname}));

    die "undefined constituency code in '$_'" if (!defined($ccode));
    die "undefined ward code in '$_'" if (!defined($wcode));
    die "undefined LA/UA code in '$_'" if (!defined($acode));
    
    $wcode =~ s/ //g;

    if (!exists($name{$acode})) {
        country($dbh, $aid{$acode} = get_area_id($dbh, $aname, 'S', 'LGD', $acode, undef, undef), 'N');
    }

    if (!exists($name{$wcode})) {
        $eaid{$wcode} = $wardname_to_ea{$aname}->{$wname};
        # Fix up parent area of district electoral area.
        $dbh->do(q#update area set parent_area_id = ? where id = ?#, {}, $aid{$acode}, $eaid{$wcode});
#        print qq#update area set parent_area_id = $aid{$acode} where id = $eaid{$wcode}\n#;
    }

    if (!exists($name{$ccode})) {
        country($dbh, $cid{$ccode} = get_area_id($dbh, $cname, 'S', 'WMC', $ccode, undef, undef), 'N');
        # Northern Ireland Assembly electoral areas are coterminous with
        # Westminster constituencies; note that they have no identifying codes
        # at all, but in memory index them by the ONS code of the coincident
        # constituency.
        my $id = $dbh->selectrow_array("
                        select id from area, area_name
                            where area.id = area_name.area_id
                              and country = 'N'
                              and type = 'NIE'
                              and name_type = 'S'
                              and name = ?
                              and ? >= generation_low
                              and ? <= generation_high", {},
                        $cname, current_generation($dbh), current_generation($dbh));
        if (defined($id)) {
            print STDERR "using existing area ID #$id for NIE '$cname'\n";
            $dbh->do('update area set generation_high = ? where id = ?', {}, new_generation($dbh), $id);
            $eid{$ccode} = $id;
        } else {
            country($dbh, $eid{$ccode} = get_area_id($dbh, $cname, 'S', 'NIE', undef, undef, undef), 'N');
        }
    }

    $name{$ccode} ||= $cname;
    $name{$wcode} ||= $wname;
    $name{$acode} ||= $aname;

    $ward_to_const{$wcode} = $ccode;
    $ward_to_district{$wcode} = $acode;
}
print STDERR "done.\n";

my %unused = map { $_ => 1 } grep(/^95/, keys %ward_to_const);

my @postcode;
my @incomplete;
my $nopos = 0;
my %cache;

my $f = new IO::File($codepointfile) or die "$codepointfile: $!";
while (defined($_ = $f->getline())) {
    chomp2($_);
    $c->parse($_) or die "unable to parse '$_'";
    # Fields:
    #   0       postcode
    #   1       accuracy code
    #   10      easting
    #   11      northing
    #   16..18  ward code
    my @f = $c->fields();

    my $pc = $f[0];
    $pc =~ s/ //g;
    my ($E, $N) = @f[10 .. 11];
    my $ward = join('', @f[15 .. 17]);
    $ward =~ s/ //g;

    # Our current (20041122) copy of Codepoint miscodes 95X (Ards DC) as 955. I
    # checked this by comparing plots of postcode locations in the various
    # wards with the maps prepared by NISRA NINIS at,
    #   http://www.ninis.nisra.gov.uk/mapxtreme/MapCatalogue.asp
    # Note that those maps (a) do not work in web browsers other than Microsoft
    # "Internet Explorer"; (b) are annotated with what appear to be an obsolete
    # series of ward codes beginning 95BB; these do not appear in the current
    # ONS indices.
    $ward =~ s#^955#95X#;

    # Skip postcodes which have no positional information (PQ of 90); these are
    # mostly PO boxes and things.
    if ($f[1] == 90) {
        ++$nopos;
        next;
    }

    # Some postcodes do not have a full ward code.
    if (length($ward) != 5) {
        push(@incomplete, [$pc, $E, $N, $ward]);
        next;
    }
    
    push(@postcode, [$pc, $E, $N, $ward]);
    $cache{"$E,$N"} = $ward;

    if (!exists($name{$ward})) {
        die "no ward for code '$ward'\n";
    } elsif (!exists($ward_to_const{$ward})) {
        die "ward '$ward' does not lie in any constituency\n";
    } elsif (!exists($ward_to_district{$ward})) {
        die "ward '$ward' does not lie in any district\n";
    }

    delete($unused{$ward});
}
die "$codepointfile: $!" if ($f->error());
$f->close();

printf STDERR "got %d good, %d bad PCs and %d with no positional information\n", scalar(@postcode), scalar(@incomplete), $nopos;
printf STDERR "%d NI wards contained no postcodes\n", scalar(keys %unused);

# Now attempt to guess the ward in which postcodes with incomplete ward codes
# lie.

@postcode = sort { $a->[1] <=> $b->[1] } @postcode;

my @reassigned;

print STDERR "trying to guess wards for postcodes with incomplete codes...\n";
foreach (@incomplete) {
    my ($pc, $E, $N, $ward) = @$_;

    if (exists($cache{"$E,$N"})) {
        # Have a postcode for this exact location already.
        push(@reassigned, [$pc, $E, $N, $cache{"$E,$N"}]);
        next;
    }

    my $radius = 10;
    my @nearby; # Nearby postcodes
    my @possibles;

    while (@nearby == 0) {
        @nearby = ( );

#        print STDERR "\r$pc  ";
        
        my ($il, $ih) = (0, $#postcode);
        while ($ih > $il + 1) {
            my $i = int(($il + $ih) / 2);
            if ($postcode[$i]->[1] < $E - $radius) {
                $il = $i;
            } elsif ($postcode[$i]->[1] > $E - $radius) {
                $ih = $i;
            } else {
                $il = $i;
                last;
            }
        }

        while ($il < @postcode && $postcode[$il]->[1] <= $E + $radius) {
            my ($dE, $dN) = ($E - $postcode[$il]->[1], $N - $postcode[$il]->[2]);
            if ($postcode[$il]->[3] =~ m#^95# and sqrt($dE**2 + $dN**2) < $radius) {
                push(@nearby, [@{$postcode[$il]}, sqrt($dE**2 + $dN**2)]);
            }
            ++$il;
        }

        if (@nearby > 0) {
            my %p = map { $_->[3] => 1 } @nearby;
            @possibles = sort keys %p;
            if (@possibles > 1) {
#                print "\r$pc possible wards are: ", join(" ", @possibles), "\n";
#                print "radius = $radius\n";
#                print join("\n", map { sprintf("%s %s %f", $_->[0], $_->[3], $_->[4]) } sort { $a->[4] <=> $b->[4] } @nearby), "\n";
            } elsif (@possibles == 1) {
                push(@reassigned, [$pc, $E, $N, $possibles[0]]);
            }
        }

        $radius *= 1.05;
    }
}

printf STDERR "reassigned %d postcodes on a nearest-neighbour basis; %d bad remain\n", scalar(@reassigned), scalar(@incomplete) - scalar(@reassigned);

push(@postcode, @reassigned);

# Now @postcode contains all the postcodes for which we have ward codes.
print STDERR "writing postcodes into database...\n";
my $n = 0;
my $check = $dbh->prepare("
    select postcode_id from postcode_area
        where postcode_id = ? and area_id = ?");
foreach (@postcode) {
    ++$n;
    printf STDERR "\r%d/%d", $n, scalar(@postcode) if (0 == ($n % 100));
    my ($pc, $E, $N, $ward) = @$_;

    my $pcid = get_postcode_id($dbh, $pc, $E, $N);
    $dbh->do('delete from postcode_area where postcode_id = ?', {}, $pcid);
    $check->execute($pcid, $eaid{$ward});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $eaid{$ward})
        if (!$check->fetchrow_array);
    $check->execute($pcid, $cid{$ward_to_const{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $cid{$ward_to_const{$ward}})
        if (!$check->fetchrow_array);
    $check->execute($pcid, $eid{$ward_to_const{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $eid{$ward_to_const{$ward}})
        if (!$check->fetchrow_array);
    $check->execute($pcid, $aid{$ward_to_district{$ward}});
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $aid{$ward_to_district{$ward}})
        if (!$check->fetchrow_array);
    $check->execute($pcid, $euro_area_id);
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $euro_area_id)
        if (!$check->fetchrow_array);
}
printf STDERR "\r%d/%d\n", $n, scalar(@postcode);
$check->finish();
# print STDERR "committing changes... ";
# $dbh->commit();
$dbh->disconnect();
print STDERR "done.\n";

exit(0);
