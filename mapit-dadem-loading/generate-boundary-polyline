#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# generate-boundary-polyline:
# Given some area IDs, generate GPolylines of them.

my $rcsid = ''; $rcsid .= '$Id: generate-boundary-polyline,v 1.8 2009-12-23 14:53:40 matthew Exp $';

use strict;

use Getopt::Long;
use mySociety::GeoUtil;
use Common;
use BoundaryLine;

my @area_ids = @ARGV;
die "Need to supply area IDs" unless @area_ids;

my $dbh = Common::connect_to_mapit_database();

my $g = current_generation($dbh);
my $s = "select id, name, area_geometry.* from area, area_name, area_geometry
    where area.id = area_name.area_id and area.id = area_geometry.area_id and name_type = 'O'
        -- and ($g >= generation_low and $g <= generation_high)
        and id in (" . join(',', @area_ids) . ")";
my $os_name_to_db_info = $dbh->selectall_hashref($s, 'id');

my ($minx, $maxx, $miny, $maxy);
foreach my $id (@area_ids) {
    local $_ = $os_name_to_db_info->{$id};
    print STDERR "$_->{name}\n";
    (my $name = $_->{name}) =~ s/[^a-z]/_/ig;
    $minx = $_->{min_e} if !defined($minx) || $_->{min_e} < $minx;
    $maxx = $_->{max_e} if !defined($maxx) || $_->{max_e} > $maxx;
    $miny = $_->{min_n} if !defined($miny) || $_->{min_n} < $miny;
    $maxy = $_->{max_n} if !defined($maxy) || $_->{max_n} > $maxy;

    my $binary_poly = $_->{polygon};
    my $c = 1;
    while ($binary_poly) {
        my ($sense, $vertice_count) = unpack('ii', $binary_poly);
        $binary_poly = substr($binary_poly, 2*4); # XXX
        my @polydata = unpack('d' . ($vertice_count*2), $binary_poly);
        $binary_poly = substr($binary_poly, $vertice_count*2*8); # XXX
        my @out;
        for (my $i=0; $i<@polydata; $i+=2) {
            my ($x, $y) = mySociety::GeoUtil::national_grid_to_wgs84($polydata[$i], $polydata[$i+1], 'G');
            push @out, 'new GLatLng(' . $x . ',' . $y . ')';
        }
        my $col = '#ff0000';
        $col = '#000000' if $sense < 0;
        print "var p$name$c = new GPolygon([" . join(",\n", @out) . "], '$col', 2, 1, '$col', 0.2)\n";
        print "map.addOverlay(p$name$c)\n";
        $c++;
    }
}

my $centre_x = ($minx + $maxx) / 2;
my $centre_y = ($miny + $maxy) / 2;
($centre_x, $centre_y) = mySociety::GeoUtil::national_grid_to_wgs84($centre_x, $centre_y, 'G');
print "map.setCenter(new GLatLng($centre_x, $centre_y), 13);\n";

$dbh->disconnect();
