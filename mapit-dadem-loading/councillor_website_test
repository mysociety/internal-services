#!/usr/bin/perl -w -I../../perllib
#
# test.pl
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

use strict;
$| = 1; # flush STDOUT afer each write

use LWP::Simple;
use Data::Dumper;
use URI;

use mySociety::CouncilMatch;
use mySociety::StringUtils qw(trim merge_spaces);
use HTML::TokeParser;
use Common;

my $m_dbh = connect_to_mapit_database();
my $d_dbh = connect_to_dadem_database();

my $samplecouncils = [

### DONE ###
# CWCWCW
# Surname first
#{id=>2504, url=>"http://www.westminster.gov.uk/councilgovernmentanddemocracy/councils/contactsconsultationandfeedback/councillors/"},

### TRIED ###
# Need subpages -- too hard
# WCWCCC
#{id=>2305, url=>"http://www.rother.gov.uk/index.cfm?articleid=187"},

#
# WCWCCC
#{id=>2287, url=>"http://www.teignbridge.gov.uk/councillors/index.htm"},

# Problems: 
#  - Misspelt ward on council website (correct by changing it for one council!)
#  - Two M Lovatts
# WCWCCC 
# Initials
#{id=>2432, url=>"http://www.staffsmoorlands.gov.uk/whoswho/councillors/councillorsbyward/councillorsbywardlist.htm"},

# Problems, wards are very mangled
# CWCWCW
# Initials
#{id=>2246, url=>"http://www.worcestershire.gov.uk/home/cs-mas-dsu/cs-mas-councillors/cs-mas-your-councillors.htm"}

### VIRGIN ###

# UMS
#{id=>2507, url=>"http://www.upmystreet.com/inf/rep/det/lgc_councillors.php3?l1=n5+1py"}

# CWCWCW
# Recursive map
{id=>2494, url=>"http://www.bexley.gov.uk/about/ward_and_map.html"},

# WCWCCC 
# Middle initials
#{id=>2626, url=>"http://www.broadland.gov.uk/broadland/members.nsf/CouncillorsByWard?openform&Start=1&Count=1000&ExpandView"},

# Problems:
# - :e
# CWCWCW
# Surname first
#{id=>2243, url=>"http://www.warwickshire.gov.uk/corporate%5Ccommitte.nsf/WCalphaWCC?OpenView&expandview&Count=150"},

# CWCWCW 
# Capital surnames
#{id=>2430, url=>"http://www.southsomerset.gov.uk/portal/page?_pageid=69,84872&_dad=cms&_schema=CMS&3410_COUNCILLORS_89102133.l_model=District%20Councillor"},

];

# canonicalise_person_name NAME
# Convert name from various formats "Fred Smith", "Smith, Fred",
# "Fred R Smith", "Smith, Fred RK" to uniform one "fred smith".  Removes
# initials except first one if there is no first name, puts surname last,
# lowercases.
sub canonicalise_person_name ($) {
    ($_) = @_;

    # Swap Lastname, Firstname
    s/^([^,]+),([^,]+)$/$2 $1/;  

    # Clear up spaces and punctuation
    s#[[:punct:]]##g;
    $_ = trim($_);
    $_ = merge_spaces($_);

    # Remove fancy words
    my $titles = "Cllr |Councillor |Dr |Hon |hon |rah |rh |Mrs |Ms |Mr |Miss |Rt Hon |Reverend |The Rev |The Reverend |Sir |Dame |Rev |Prof ";
    my $honourifics = " MP| CBE| OBE| MBE| QC| BEM| rh| RH| Esq| QPM| JP| FSA| Bt| BEd| Hons| TD| MA| QHP| DL| CMG| BB| AKC| Bsc| Econ| LLB| GBE| QSO| BA| FRSA| FCA| DD| KBE| PhD";
    s#^($titles )*##;
    s#( $honourifics)^##;

    # Split up initials unspaced 
    s/\b([[:upper:]])([[:upper:]])\b/$1 $2/g;
    # Remove initials apart from first name/initial
    s/\b(\S+ )((?:[[:upper:]] )+)/$1/;

    # Remove case
    $_ = lc($_);

    return $_;
}

print canonicalise_person_name("Joga Singh Minhas");
exit;

# canonicalise_ward_name WARD
# Returns Ward name with extra suffixes (e.g. Ward) removed, and in lowercase.
sub canonicalise_ward_name ($) {
    ($_) = @_;
    s# Ward$##;
    return mySociety::CouncilMatch::canonicalise_council_name($_);
}


sub check_councillors($) {
    my ($spec) = @_;
    print "Council " . $spec->{id} . "\n";

    # Get known data from database
    my @raw = mySociety::CouncilMatch::get_raw_data($spec->{id}, $d_dbh);
    my $wardnames = $m_dbh->selectall_hashref(
            q#select * from area_name, area where area_name.area_id = area.id and
            parent_area_id = ?#, 'name', {}, $spec->{id});
    my $wardnamescanon;
    do { $wardnamescanon->{canonicalise_ward_name($_)} = $wardnames->{$_} } for keys %$wardnames;
    # Various lookup tables
    my $wardsbyid;
    do { $wardsbyid->{$wardnames->{$_}->{id}} = $wardnames->{$_}->{name} } for keys %$wardnames;
    my $cllrsbykey;
    do { $cllrsbykey->{$_->{key}} = $_ } for @raw;
    my $cllrsbywardid;
    do { push @{$cllrsbywardid->{$wardnames->{$_->{ward_name}}->{id}}}, $_ if (defined($wardnames->{$_->{ward_name}})) } for @raw;

    # Get all HTML from councillor list web page, and tidy
    print "Getting main page... $spec->{url} ";
    my $mainpage = get($spec->{url});
    print "...got\n";
    my @lumps = mySociety::StringUtils::break_into_lumps($mainpage);
    my $content = $mainpage;

    # Get out next layer of URLs
    my @urls;
    my $p = HTML::TokeParser->new(\$mainpage);
    # include also clickable maps "area"
    while (my $token = $p->get_tag("area")) { #, "a")) {
        my $url = $token->[1]{href};
        next if !$url;
        next if $url =~ m/^\#/;
        next if $url =~ m/\.pdf$/;
        if (!URI->new($url)->scheme()) { # only relative ones
            my $uri = URI->new_abs($url, $spec->{url});
            $url = $uri->as_string();
            push @urls, $url;
        }
    }
#=cut

    # scan_with_pattern PATTERN
    # Scan lumps to find wards and councillors in given pattern
    my $scan_with_pattern = sub {
        my ($pattern) = @_;
        die "scan_with_pattern: invalid pattern $pattern" if ($pattern ne "WCWCCC" && $pattern ne "CWCWCW");

        my $error = "";
        my $warddone;
        do { $warddone->{$wardnames->{$_}->{id}} = 0 if $wardnames->{$_}->{id}} for keys %$wardnames;
        my $repdone;
        do { $repdone->{$_->{key}} = 0 } for @raw;
    
        # Scan for stuff
        my $lastwardid = undef;
        my $lastcllrkey = undef;
        foreach my $lump (@lumps) {
            my $canon_lump = canonicalise_person_name($lump);
            print "lump $canon_lump\n";

            my $matches = 0;
            foreach my $rep (@raw) {
                my $first = $rep->{rep_first};
                my $last = $rep->{rep_last};
                # Match representative names various ways
                my $canon_name = canonicalise_person_name("$first $last");
#                print "name: $canon_name\n";
                if ($canon_lump =~ m/^[[:alpha:]] /) {
                    #print "LUMP BEGAN INITIAL\n";
                    #print "$canon_lump : $canon_name\n";
                    # If lump begins with an initial, initialise first word of name
                    $canon_name =~ s/^([[:alpha:]])([[:alpha:]]+) /$1 /;
                    #print "$canon_lump : $canon_name\n";
                }
                if ($canon_lump eq $canon_name) {
                    #print "C MATCH!!!\n";
                    $lastcllrkey = $rep->{key};
                    $repdone->{$lastcllrkey} = 1;
                    $matches ++;
                    if ($pattern eq "WCWCCC") {
                        # check ward right
                        if (!(defined $lastwardid)) {
                            $error .= $spec->{id} . ": councillor $first $last in wrong ward, ge " . $rep->{ward_name} . " none on website\n";
                        } elsif (!(defined $wardnames->{$rep->{ward_name}})) {
                            $error .= $spec->{id} . ": councillor $first $last has unknown ward " . $rep->{ward_name} . "\n";
                        } elsif ($wardnames->{$rep->{ward_name}}->{id} != $lastwardid) {
                            $error .= $spec->{id} . ": councillor $first $last in wrong ward, ge " . $rep->{ward_name} . " website " . $wardsbyid->{$lastwardid} . "\n";
                        }
                    }
                }
            }
            if ($matches > 1) {
                $error .= $spec->{id} . ": $lump matched multiple councillors\n";
            }

            my $canonlump = canonicalise_ward_name($lump);
            if (exists($wardnamescanon->{$canonlump})) {
                #print "W MATCH!!!\n";
                $lastwardid = $wardnamescanon->{$canonlump}->{id};
                $warddone->{$lastwardid} = 1;
                if ($pattern eq "CWCWCW") {
                    # check councillor right
                    if (!$lastcllrkey) {
                        $error .= $spec->{id} . ": ward $lump without councillor\n";
                    } elsif (!grep { $_->{key} eq $lastcllrkey } @{$cllrsbywardid->{$lastwardid}}) {
                        #print Dumper(@{$cllrsbywardid->{$lastwardid}});
                        #print "lastcllrkey $lastcllrkey\n";
                        $error .= $spec->{id} . ": councillor " . $cllrsbykey->{$lastcllrkey}->{rep_first} . " " .
                            $cllrsbykey->{$lastcllrkey}->{rep_last} . " appears in wrong ward, ge " . 
                            $cllrsbykey->{$lastcllrkey}->{ward_name} . " website $lump\n";
                    }
                }
            }
        }

        # Check all got
        foreach my $ward (keys %$warddone) {
            if (!$warddone->{$ward}) {
                $error .= $spec->{id} . ": ward not matched " . $wardsbyid->{$ward} . " $ward\n";
            }
        }
        foreach my $rep (keys %$repdone) {
            if (!$repdone->{$rep}) {
                $error .= $spec->{id} . ": councillor not matched ge " . $cllrsbykey->{$rep}->{rep_first} . " " . $cllrsbykey->{$rep}->{rep_last} . "\n";
            }
        }

        return $error;
    };

    my $error1 = &$scan_with_pattern("WCWCCC");
    my $error2 = &$scan_with_pattern("CWCWCW");
    my $ecount1 = ($error1 =~ tr/\n/\n/);
    my $ecount2 = ($error2 =~ tr/\n/\n/);
    if ($ecount1 > 20 and $ecount2 > 20) {
        # Nothing much good, so try recursive get
        foreach my $url (@urls) {
            print "Getting... $url ";
            my $subpage = get($url);
            print "...got\n";
            push @lumps, mySociety::StringUtils::break_into_lumps($subpage);
        }
        $error1 = &$scan_with_pattern("WCWCCC");
        $error2 = &$scan_with_pattern("CWCWCW");
        $ecount1 = ($error1 =~ tr/\n/\n/);
        $ecount2 = ($error2 =~ tr/\n/\n/);
    }

    if (!$error1) {
        print "WCWCCC worked\n";
    }
    if (!$error2) {
        print "CWCWCW worked\n";
    }
    if ($error1 && $error2) {
        if ($ecount1 < $ecount2) {
            print "shortest is WCWCCC\n";
            print $error1;
        } else {
            print "shortest is CWCWCW\n";
            print $error2;
        }
    }
}

foreach my $spec (@$samplecouncils) {
    check_councillors($spec);
}

$m_dbh->disconnect();
$d_dbh->disconnect();

