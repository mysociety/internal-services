#!/usr/bin/perl -w -I../../perllib
#
# dadem_goveval_load
# Takes CSV files containing contact details for representatives from
# GovEval or similar, and loads them into DaDem.  Requires that GovEval
# names are already in the area_name table in MaPit, use
# load_goveval_name first to do that.
#
# Parameters: 
# $1 - kind of data, currently choose from: mep, mp, msp, wam, lam, ds
# stdin - the CSV file from GovEval or FaxYourMP
# make sure ../conf/general is configured for mapit db
#
# Example usages:
# cat ../../../repdata/goveval/mep-20041001.csv | ./dadem_goveval_load mep
# cat ../../../repdata/goveval/faxyourmp-mp-20041207-withcons.csv | ./dadem_goveval_load mp
# cat ../../../repdata/goveval/msp-sp{c,e}-20041001.csv | ./dadem_goveval_load msp
# cat ../../../repdata/goveval/wam-20041001.csv | ./dadem_goveval_load wam
# cat ../../../repdata/goveval/gla-20041001.csv | ./dadem_goveval_load lam
# cat ../../../repdata/mysociety/democratic-services-rev7.csv | ./dadem_goveval_load ds
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: dadem_goveval_load,v 1.13 2005-02-04 14:21:14 francis Exp $';

use strict;

use DBI;
use DBD::SQLite;
use Text::CSV_XS;
use Data::Dumper;
use Common;
use mySociety::Parties;
use mySociety::VotingArea;
use mySociety::CouncilMatch;
#DBI->trace(1);

my $kind = lc(shift(@ARGV));
die "specify what kind of CSV file" if (!defined($kind));
my $types;
my $name_type_char;
if ($kind eq "mep") {
    $types = [qw(EUR)];
} elsif ($kind eq "mp") {
    $types = [qw(WMC)];
} elsif ($kind eq "msp") {
    $types = [qw(SPC SPE)];
} elsif ($kind eq "wam") {
    $types = [qw(WAC WAE)];
} elsif ($kind eq "lam") {
    $types = [qw(LAC LAE)];
} elsif ($kind eq "ds") {
    $types = $mySociety::CouncilMatch::parent_types;
} else {
    die "Please specify 'mep', 'mp', 'msp', 'wam', 'lam', 'ds'";
}

my $m_dbh = connect_to_mapit_database();
my $d_dbh = connect_to_dadem_database();

$d_dbh->do(q#delete from representative where 
            (# . join(' or ', map { "area_type = '$_'" } @$types) . q#)#);

# %name_to_id
# Cache of name-->id map of all the areas
my %name_to_id;
my %name_to_type;
my $s = $m_dbh->prepare(
        q#select area_id, name, type from area_name, area
            where area_name.area_id = area.id
            and (# . join(' or ', map { "type = '$_'" } @$types) . q#)#
    );
$s->execute();
while (my ($area_id, $name, $type) = $s->fetchrow_array()) {
    #print "$area_id $name $type\n";

    # "Durham" without specifcying "County" or "City" is no use
    next if ($kind eq "ds" and $name eq "Durham");

    die "duplicate name $name of differing id or type" if (exists($name_to_id{$name}) and (($name_to_id{$name} != $area_id) or ($name_to_type{$name} ne $type)));

    $name_to_id{$name} = $area_id;
    $name_to_type{$name} = $type;
}

# Special case, should perhaps have function in MaPit instead of the select
# above, which includes the special cases there.
if ($kind eq "lam") {
    $name_to_id{"London Assembly"} = mySociety::VotingArea::LAE_AREA_ID;
    $name_to_type{"London Assembly"} = "LAE";
}

# Various forms of null
sub nullify_if_null($) {
    $_ = shift;
    return $_ if !defined($_);
    return undef if ($_ eq "");
    return undef if ($_ eq "NULL");
    return undef if ($_ eq "byelection");
    return $_;
}

# Read CSV file, load into dadem
my $C = new Text::CSV_XS({ binary => 1 });
<STDIN>;    # header line
while (my $line = <STDIN>) {
    chomp($line);
    $C->parse($line);
    map { die "Not valid field in $line" if (!defined $_) } $C->fields();

    my ($finalcons, $finalname, $finalparty, $finalmethod, $finalemail, $finalfax);
    if ($kind eq "mep" or $kind eq "msp" or $kind eq "wam" or $kind eq "lam") {
        my ($first, $last, $constituency, $party, $email, $fax) = map { trim_spaces($_) } $C->fields();

        $finalcons = $constituency;
        $finalname = "$first $last";
        $finalparty = $party;

        $finalcons = "London Assembly" if $kind eq "lam" and $finalcons eq "Proportionally Elected Member";
        die "Ken Livingstone is not a LAE type" if ($kind eq "lam" and $finalname eq "Ken Livingstone");

        $finalemail = nullify_if_null($email);
        $finalfax = nullify_if_null($fax);
        if (defined($finalemail) and !defined($finalfax)) {
            $finalmethod = "email";
        } elsif (!defined($finalemail) and defined($finalfax)) {
            $finalmethod = "fax";
        } elsif (!defined($finalemail) and !defined($finalfax)) {
            $finalmethod = "unknown";
        } else {
            $finalmethod = "either";
        }

    } elsif ($kind eq "mp") {
        my ($name, $constituency, $email, $fax, $phone, $constituencyfax, $party) = map { trim_spaces($_) } $C->fields();

        $finalcons = $constituency;
        $finalname = $name;
        $finalparty = $party;

        $finalemail = nullify_if_null($email);
        $finalfax = nullify_if_null($fax);
        if (!defined($finalfax)) {
            $finalfax = nullify_if_null($constituencyfax);
        }

        if (defined($finalemail)) {
            $finalmethod = "email";
        } elsif (defined($finalfax)) {
            $finalmethod = "fax"; 
        } else {
            $finalmethod = "unknown"; 
        }

        if ($email eq "shame") {
            $finalemail = undef;
            $finalfax = undef;
            $finalmethod = "shame";
        }

    } elsif ($kind eq "ds") {
        my ($council, $email, $fax, $web) = map { trim_spaces($_) } $C->fields();

        $finalcons = $council;
        $finalname = "Democratic Services";
        $finalparty = "NOT A PERSON";

        $finalemail = nullify_if_null($email);
        $finalfax = nullify_if_null($fax);

        # We can accept either fax or email if present in CSV, as
        # Tom paintsakingly found it all, so all data is good.
        if (defined($finalemail) and !defined($finalfax)) {
            $finalmethod = "email";
        } elsif (!defined($finalemail) and defined($finalfax)) {
            $finalmethod = "fax";
        } elsif (!defined($finalemail) and !defined($finalfax)) {
            $finalmethod = "unknown";
        } else {
            $finalmethod = "either";
        }

    } else {
        die "Missing kind in code";
    }

    die "unmatched GovEval name '$finalcons', not in database" unless (exists($name_to_id{$finalcons}));
    my $area_id = $name_to_id{$finalcons};
    my $area_type = $name_to_type{$finalcons};

    $finalparty = $mySociety::Parties::canonical{$finalparty};
    die "party not known for '$line'" if (!defined($finalparty));

#    print "insert into representative (area_id, area_type, name,
#        party, method, email, fax) values (?, ?, ?, ?, ?, ?, ?)",
#        $area_id, " ", $area_type, " ", $finalname, " ", $finalparty, "
#        ", $finalmethod, " ", $finalemail, " ", $finalfax;
#    print "\n";

    $d_dbh->do("insert into representative (area_id, area_type, name,
        party, method, email, fax) values (?, ?, ?, ?, ?, ?, ?)", {},
        $area_id, $area_type, $finalname, $finalparty, $finalmethod,
        $finalemail, $finalfax);
}
 
$m_dbh->disconnect();
$d_dbh->commit();
$d_dbh->disconnect();

