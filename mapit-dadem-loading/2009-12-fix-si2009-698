#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# 2009-12-fix-si2009-698:
# SI 2009/698 made some alterations to the boundaries of four Parliamentary
# constituencies. This script makes those alterations as ours are out of date.
#
# Copyright (c) 2009 UK Citizens Online Democracy. All rights reserved.
# Email: matthew@mysociety.org; WWW: http://www.mysociety.org/
#
# $Id: 2009-12-fix-si2009-698,v 1.1 2009-12-23 14:54:07 matthew Exp $
#

use strict;

use DBD::Pg;
use mySociety::Polygon;

use Common;
use Area;
use BoundaryLine qw(doublesize);

my $dbh = Common::connect_to_mapit_database();

# The wards that actually make up the constituencies, taken from SI 2009/698.
my %construction = (
    'Daventry' => {
        'Daventry' => [],
        'South Northamptonshire' => [ 'Harpole and Grange', 'Heyfords and Bugbrooke' ],
        'Wellingborough' => [ 'Earls Barton', 'West' ]
    },
    'South Northamptonshire' => {
        'Northampton' => [ 'East Hunsbury', 'Nene Valley', 'West Hunsbury' ],
        'South Northamptonshire' => [ 'Astwell', 'Blakesley and Cote', 'Blisworth and Roade', 'Brackley East', 'Brackley South', 'Brackley West', 'Brafield and Yardley', 'Cosgrove and Grafton', 'Danvers and Wardoun', 'Deanshanger', 'Grange Park', 'Hackleton', 'Kings Sutton', 'Kingthorn', 'Little Brook', 'Middleton Cheney', 'Old Stratford', 'Salcey', 'Silverstone', 'Steane', 'Tove', 'Towcester Brook', 'Towcester Mill', 'Washington', 'Whittlewood' ]
    },
    'Somerton and Frome' => {
        'Mendip' => [ 'Ammerdown', 'Beckington and Selwood', 'Butleigh and Baltonsborough', 'Coleford and Holcombe', 'Cranmore, Doulting and Nunney', 'Creech', 'Frome Berkley Down', 'Frome College', 'Frome Keyford', 'Frome Market', 'Frome Oakfield', 'Frome Park', 'Postlebury', 'Rode and Norton St. Philip', 'The Pennards and Ditcheat' ],
        'South Somerset' => [ 'Blackmoor Vale', 'Bruton', 'Burrow Hill', 'Camelot', 'Cary', 'Curry Rivel', 'Islemoor', 'Langport and Huish', 'Martock', 'Milborne Port', 'Northstone', 'Tower', 'Turn Hill', 'Wessex', 'Wincanton' ]
    },
    'Wells' => {
        'Mendip' => [ 'Ashwick, Chilcompton and Stratton', 'Chewton Mendip and Ston Easton', 'Croscombe and Pilton', "Glastonbury St. Benedict's", "Glastonbury St. Edmund's", "Glastonbury St. John's", "Glastonbury St. Mary's", 'Moor', 'Rodney and Westbury', 'St. Cuthbert Out North', 'Shepton East', 'Shepton West', 'Street North', 'Street South', 'Street West', 'Wells Central', "Wells St. Cuthbert's", "Wells St. Thomas'", 'Wookey and St. Cuthbert Out West' ],
        'Sedgemoor' => [ 'Axbridge', 'Axe Vale', 'Berrow', 'Brent North', 'Burnham North', 'Burnham South', 'Cheddar and Shipham', 'Highbridge', 'Knoll', 'Wedmore and Mark' ]
    }
);

my %constituency;
foreach my $constituency (keys %construction) {
    my $const_id = $dbh->selectrow_array("select id from area, area_name where id=area_id and name_type='O' and name=? and generation_high=13", {}, "$constituency Co Const");
    die "Couldn't find $constituency" unless $const_id;
    $constituency{$constituency} = $const_id;
}
foreach my $constituency (keys %construction) {
    my %data = (
        min_e => undef, max_e => undef,
        min_n => undef, max_n => undef,
        area => 0, parts => 0, binary_poly => '',
    );
    my $const_id = $constituency{$constituency};
    print "$constituency = $const_id\n";
    foreach my $council (keys %{$construction{$constituency}}) {
        my $council_id = $dbh->selectrow_array("select id from area, area_name where id=area_id and name_type='O' and name=? and generation_high>=12", {}, "$council District");
        die "Couldn't find $council" unless $council_id;
        print "  $council = $council_id\n";
        my $whole_council = 1;
        foreach my $ward (@{$construction{$constituency}{$council}}) {
            $whole_council = 0;
            my $ward_id = $dbh->selectrow_array("select id from area, area_name where id=area_id and name_type='O' and parent_area_id=? and name=? and generation_high>=12", {}, $council_id, "$ward Ward");
            die "Couldn't find $ward" unless $ward_id;
            print "    $ward = $ward_id\n";
            add($ward_id, \%data);
            fix_postcodes($ward_id, $constituency) if $council =~ /South Northamptonshire|Mendip/;
        }
        if ($whole_council) {
            add($council_id, \%data);
        }
    }

    $data{centre_e} = ($data{min_e} + $data{max_e}) / 2;
    $data{centre_n} = ($data{min_n} + $data{max_n}) / 2;

    $dbh->do("delete from area_geometry where area_id=?", {}, $const_id);
    $dbh->do("insert into area_geometry (
        area_id, centre_e, centre_n, min_e, min_n,
        max_e, max_n, area, parts
    ) values (
        ?, ?, ?, ?, ?,
        ?, ?, ?, ?
    ) ", {},
        $const_id, $data{centre_e}, $data{centre_n}, $data{min_e}, $data{min_n},
        $data{max_e}, $data{max_n}, $data{area}, $data{parts}
    );

    # Horrid. To insert a value into a BYTEA column we need to do a little
    # parameter-binding dance:
    my $s = $dbh->prepare(q#update area_geometry set polygon = ? where area_id = ?#);
    $s->bind_param(1, $data{binary_poly}, { pg_type => DBD::Pg::PG_BYTEA });
    $s->bind_param(2, $const_id);
    $s->execute();
}

$dbh->commit;

# Take the current data out of the database, to collate it all together.
sub add {
    my ($id, $data) = @_;
    my $geometry = $dbh->selectrow_hashref('select * from area_geometry where area_id=?', {}, $id);
    $data->{min_e} = $geometry->{min_e} if !defined($data->{min_e}) || $geometry->{min_e} < $data->{min_e};
    $data->{min_n} = $geometry->{min_n} if !defined($data->{min_n}) || $geometry->{min_n} < $data->{min_n};
    $data->{max_e} = $geometry->{max_e} if !defined($data->{max_e}) || $geometry->{max_e} > $data->{max_e};
    $data->{max_n} = $geometry->{max_n} if !defined($data->{max_n}) || $geometry->{max_n} > $data->{max_n};
    $data->{area} += $geometry->{area};
    $data->{parts} += $geometry->{parts};
    $data->{binary_poly} .= $geometry->{polygon};
}

# Some postcodes will be pointing at the wrong constituency;
# all postcodes in WARD_ID should be in CONSTITUENCY.
sub fix_postcodes {
    my ($ward_id, $constituency) = @_;
    my $new_area_id = $constituency{$constituency};
    my $old_constituency;
    $old_constituency = 'Wells' if $constituency eq 'Somerton and Frome';
    $old_constituency = 'Somerton and Frome' if $constituency eq 'Wells';
    $old_constituency = 'Daventry' if $constituency eq 'South Northamptonshire';
    $old_constituency = 'South Northamptonshire' if $constituency eq 'Daventry';
    my $old_area_id = $constituency{$old_constituency};
    my $count = $dbh->selectrow_array('select count(*) from postcode_area as pa1, postcode_area as pa2 where pa1.postcode_id=pa2.postcode_id and pa1.area_id=? and pa2.area_id=?', {}, $ward_id, $old_area_id);
    return if $count == 0;
    $dbh->do('update postcode_area set area_id=? where postcode_id in (select postcode_id from postcode_area as pa where pa.area_id=?) and area_id=?',
        {}, $new_area_id, $ward_id, $old_area_id);
}
