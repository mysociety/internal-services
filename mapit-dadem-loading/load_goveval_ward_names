#!/usr/bin/perl -w
#
# load_goveval_names
# Load in GovEval data, match names to Ordnance Survey once in the MaPit
# database, and add in the GovEval names as alternates.
#
# Parameters:  Pipe the councillors.csv file from GovEval into standard
# input.  Optionally give an area id to process just that council ID.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: load_goveval_ward_names,v 1.4 2004-12-07 16:33:20 francis Exp $';

use strict;

use DBI;
use DBD::Pg;
use Text::CSV;
use Data::Dumper;

use Common;

my $runoneid = shift(@ARGV);
my $dbh = connect_to_mapit_database();

my $parent_types = [qw(DIS LBO MTD UTA LGD CTY)];
my $child_types = [qw(DIW LBW MTW UTE UTW LGW CED)];

my $verbosity = 1;

# canonicalise_council_name NAME
# Convert the NAME of a council into a "canonical" version of the name.
# That is, one with all the parts which often vary between spellings
# reduced to the simplest form.  e.g. Removing the word "Council" and
# punctuation.
sub canonicalise_council_name ($) {
    $_ = shift;

    if (m/^Durham /) {
        # Durham County and Durham District both have same name (Durham)
        # so we leave in the type (County/District) as a special case
        s# City Council# District#;
        s# County Council# County#;
    } else {
        s#\s*\(([A-Z]{2})\)##; # Pendle (BC) => Pendle
        s#(.+) - (.+)#$2#;     # Sir y Fflint - Flintshire => Flintshire

        s#^City and County of ##;         # City and County of the City of London => the City of London
        s#^The ##i;
        s# City Council$##;    # OS say "District", GovEval say "City Council", we drop both to match
        s# County Council$##;  # OS say "District", GovEval say "City Council", we drop both to match
        s# Borough Council$##; # Stafford Borough Council => Stafford
        s# Council$##;         # Medway Council => Medway
        s# City$##;            # Liverpool City => Liverpool
        s#^City of ##;         # City of Glasgow => Glasgow
        s#^County of ##;
        s#^Corp of ##;         # Corp of London => London
        s# District$##;
        s# County$##;
        s# City$##;
        s# London Boro$##;

        s#sh'r$#shire#;       # Renfrewsh'r => Renfrewshire
        s#W\. Isles#Na H-Eileanan an Iar#;    # Scots Gaelic(?) name for Western Isles
        s#^Blackburn$#Blackburn with Darwen#;

        s#\bN\.\s#North #g;    # N. Warwickshire => North Warwickshire
        s#\bS\.\s#South #g;    # S. Oxfordshire => South Oxfordshire
        s#\bE\.\s#East #g;     # North E. Derbyshire => North East Derbyshire
        s#\bW\.\s#West #g;     # W. Sussex => West Sussex
        s#\bGt\.\s#Great #g;   # Gt. Yarmouth => Great Yarmouth

        s#&#and#g;
        s#-# #g;
        s#'##g;                # King's Lynn => Kings Lynn
        s#,##g;                # Rhondda, Cynon, Taff => Rhondda Cynon Taff
    }
    
    return $_;
}

# %parent_to_id
# Hash of council canonical name to council ID from existing MaPit data.
my %parent_to_id;

# Cache of name-->id map of all the parent area types (District Council,
# Unitary Authority etc....)
my $s = $dbh->prepare(
        q#select distinct on (area_id) area_id, name from area_name, area
            where area_name.area_id = area.id
            and (# . join(' or ', map { "type = '$_'" } @$parent_types) . q#)#
    );
$s->execute();

while (my ($area_id, $name) = $s->fetchrow_array()) {
    # Create canonical version of name and also hash it as lookup
    $_ = canonicalise_council_name($name);
    if (exists($parent_to_id{$_})) {
        die "Already have id for canonicalised $_, being " .  $parent_to_id{$_} .  "\n";
    }
    $parent_to_id{$_} = $area_id;
printf "%38s %30s %d\n", $name, $_, $area_id;
}
 
# Load the GovEval data.
my $C = new Text::CSV;
<STDIN>;    # header line

# $councils
# Reference to hash of council ID to reference to hash of information about the
# council, including:
#   canonname       its canonical name
#   govevalname     its GovEval name
#   wards           reference list of wards/EDs
#   gotwards        reference of hash containing key for name of each present
#                   ward/ED
my $councils;

while (my $line = <STDIN>) {
    chomp($line);
    $C->parse($line);
    my ($first, $last, $vdiv, $council, $email) = map { trim_spaces($_) } $C->fields();

    die "council not defined for line '$line'\n" unless (defined($council));

    # Special case for areas with elected mayors.
    next if $vdiv eq "Elected Mayor";
    
    $_ = canonicalise_council_name($council);

    die "no council in database matches canonical name '$_'\n" unless (exists($parent_to_id{$_}));

    my $id = $parent_to_id{$_};
    
    $councils->{$id}->{canonname} = $_;
    $councils->{$id}->{govevalname} = $council;
    if (!exists($councils->{$id}->{gotwards}->{$vdiv})) {
        push @{$councils->{$id}->{wards}}, { name => $vdiv };
        $councils->{$id}->{gotwards}->{$vdiv} = 1;
    }
}

# Print out councils in $parent_to_id for which nobody has been added to $councils
my @ck = keys %$councils;
my @pk = keys %parent_to_id;
if ($#ck != $#pk) {
    print STDERR "Council count mismatch:\n";
    print STDERR "There are " . scalar(@ck) . " councils in GovEval data\n";
    print STDERR "There are " . scalar(@pk) . " councils in database\n";

    my %p = %parent_to_id;
    foreach (keys %$councils) {
        delete($p{$councils->{$_}->{canonname}});
    }

    print "Database councils not matched:\n", join("\n", sort keys %p), "\n";
    
#    die; # ignore for the moment
}
foreach my $parent (@pk) {
    my $id = $parent_to_id{$parent};
    die "\$parent_to_id{'$parent'} not present" unless (defined($id));
    if (!exists($councils->{$id})) {
        print STDERR "Missing $parent id $id from GovEval data\n"; 
    }
}

# Special debugging case
if (defined $runoneid) {
    my $council = $councils->{$runoneid}->{govevalname};
    match_council_wards($council, $runoneid);
    exit;
}

# For each "council" (or similar), get list of "wards" (or similar) and match it up
# with what is in the database already.
my $success = 0;
my $count = 0;
foreach my $id (keys %$councils) {
    my $council = $councils->{$id}->{govevalname};
    my $ret = match_council_wards($council, $id);
    $success++ if $ret;
    $count++;
}
print "Success for $success/$count councils\n";
print "Failed for " . ($count-$success) . " councils\n";

sub match_council_wards ($$) {
    my ($council, $id) = @_;
    print "Council: $council Area: $id\n" if $verbosity > 0;
    my $error = 0;

    # Set of wards GovEval have
    my $wards_goveval = $councils->{$id}->{wards};

    # Set of wards already in database (from Ordnance Survey / ONS)
    my $rows = $dbh->selectall_arrayref(q#select distinct on (area_id) area_id, name from area_name, area where
        area_name.area_id = area.id and parent_area_id = ?#, {}, $id);
    my $wards_database;
    foreach my $row (@$rows) { 
        my ($area_id, $name) = @$row;
        push @{$wards_database}, { name => $name, id => $area_id };
    }

    @$wards_database = sort { $a->{name} cmp $b->{name} } @$wards_database;
    @$wards_goveval = sort { $a->{name} cmp $b->{name} } @$wards_goveval;

    printf "%38s %38s\n", 'OS/ONS ward name', 'GovEval ward name';
    print "-" x 38, ' ', "-" x 38, "\n";
    for (my $i = 0; $i < @$wards_database || $i < @$wards_goveval; ++$i) {
        my ($d, $g) = qw(- -);
        $d = $wards_database->[$i]->{name} if (exists($wards_database->[$i]));
        $g = $wards_goveval->[$i]->{name} if (exists($wards_goveval->[$i]));
        printf "%38s %38s\n", $d, $g;
    }

    if (@$wards_goveval != @$wards_database) {
        die "different numbers of wards";
    }
    
    my $dump_wards = sub {
        print STDERR "\t ==== Possible matches (GovEval => Database):\n";
        foreach my $g (@$wards_goveval) {
            if (exists($g->{matches})) {
                foreach my $d (@{$g->{matches}}) {
                    print STDERR "\t" . $g->{name} . " => " .  $d->{id} . " " .  $d->{name} . "\n";
                    $d->{referred} = 1;
                }
            }
        }
        print STDERR "\t ---- Other Database wards: \n";
        foreach my $d (@$wards_database) {
            if (!exists($d->{referred})) {
                print STDERR "\t" . $d->{id} . " " . $d->{name} . "\n";
            }
        }
        print STDERR "\t ---- Other GovEval wards: \n";
        foreach my $g (@$wards_goveval) {
            if (!exists($g->{matches})) {
                print STDERR "\t" . $g->{name} . "\n";
            }
        }
        print STDERR "\n";
    };

    # Work out area_id for each GovEval ward
    foreach my $g (@$wards_goveval) {
        # Find the entry in database which best matches each GovEval
        # name, store multiple same-length ties.
        my $longest_len = -1;
        my $longest_matches = undef;
        foreach my $d (@$wards_database) {
            my $match1 = $g->{name};
            my $match2 = $d->{name};
            my $common_len = Common::placename_match_metric($match1, $match2);
          
            # If more common characters, store it
            if ($common_len > $longest_len) {
                $longest_len = $common_len;
                $longest_matches = undef;
                push @{$longest_matches}, $d;
            } elsif ($common_len == $longest_len) {
                push @{$longest_matches}, $d;
            }
        }

        # Longest len
        if ($longest_len < 3) {
            print STDERR "${id} ${council}: Couldn't find match in database for GovEval ward " .  $g->{name} . " (longest common substring < 3)\n";
            $error = 1;
        } else {
            # Record the best ones
            $g->{matches} = $longest_matches;
            #print Dumper($longest_matches);
            # If exactly one match, use it for definite
            if ($#$longest_matches == 0) {
                push @{$longest_matches->[0]->{used}}, $g;
                $g->{id} = $longest_matches->[0]->{id};
                print "Best is: " . $g->{name} . " is " .  $longest_matches->[0]->{name} . " " .  $longest_matches->[0]->{id} . "\n" if $verbosity > 0;
            } else {
                foreach my $longest_match (@{$longest_matches}) {
                    print "Ambiguous are: " . $g->{name} . " is " .  $longest_match->{name} . " " .  $longest_match->{id} .  "\n" if $verbosity > 0;
                }

            }
        }
    }

    # Second pass to clear up those with two matches 
    # e.g. suppose there are both "Kilbowie West Ward", "Kilbowie Ward"
    # The match of "Kilbowie Ward" against "Kilbowie West" and "Kilbowie"
    # will find Kilbowie as shortest substring, and have two matches.
    # We want to pick "Kilbowie" not "Kilbowie West", but can only do so
    # after "Kilbowie West" has been allocated to "Kilbowie West Ward".
    # Hence this second pass.
    foreach my $g (@$wards_goveval) {
        next if (exists($g->{id}));
        next if (!exists($g->{matches}));

        # Find matches which haven't been used elsewhere
        my @left = grep { !exists($_->{used}) } @{$g->{matches}};
        my $count = scalar(@left);
       
        if ($count == 0) {
            # If there are none, that's no good
            print STDERR "${id} ${council}: Couldn't find match in database for GovEval ward " . $g->{name} . " (had ambiguous matches, but all been taken by others)\n";
            $error = 1;
        } elsif ($count > 1) {
            # If there is more than one
            print STDERR "${id} ${council}: Only ambiguous matches found for GovEval ward " .  $g->{name} .  ", matches are " . join(", ", map { $_->{name} } @left) . "\n";
            $error = 1;
        } else {
            my $longest_match = $left[0];
            push @{$longest_match->{used}}, $g;
            $g->{id} = $longest_match->{id};
            $g->{matches} = \@left;
            print "Resolved is: " . $g->{name} . " is " .  $longest_match->{name} . " " .  $longest_match->{id} . "\n" if $verbosity > 0;
        }
    }
    

    # Check we used every single ward (rather than used same twice)
    foreach my $d (@$wards_database) {
        if (!exists($d->{used})) {
            print STDERR "${id} ${council}: Ward in database, not in GovEval data: " . $d->{name} . " id " . $d->{id} . "\n";
            $error = 1;
        } else {
            delete $d->{used};
        }
    }

    # Give up
    if ($error) {
        &$dump_wards();
        return 0;
    }

    # Clean up looped references
    foreach my $d (@$wards_database) {
        delete $d->{used};
    }
    foreach my $g (@$wards_goveval) {
        delete $g->{matches};
    }

    # Add name alises to the database
    foreach my $g (@$wards_goveval) {
        # next if (!exists($g->{id}));
        # $dbh->do(
#        print "insert into area_name (area_id, name_type, name) values (?, 'G',?)", $g->{id}, $g->{name};
#        print "\n";
    }

#    print Dumper($wards_goveval);
#    print Dumper($wards_database);
    print "--------------------------------------------------\n" if $verbosity > 0;

    return 1;
}

$dbh->disconnect();



