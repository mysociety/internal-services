#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# process_boundary_line:
# Load the Boundary-Line polygons into memory, and compare postcodes (e.g.
# from CodePoint) against their areas, to form the database used by MaPit.
#
# The strategy here is as follows: 
#
# a. For each area, we read each polygon from the OS-supplied NTF files. We
#    represent these in memory as packed arrays of doubles (otherwise the
#    memory requirement exceeded poor caesious's little mind). This also makes
#    use of the C pnpoly function (see below) more convenient, which speeds
#    things up a little.  
#
#    We assemble a "spatial hash" which maps square regions (presently of size
#    1km) to the electoral/administrative areas which overlap them. 
#
# b. Now we are ready to compute point-polygon intersections. We read the
#    CodePoint data from the OS-supplied CSV files, ignoring data for Northern
#    Ireland (processed separately, since Boundary-Line only covers GB) and
#    determine the locations in which each point lies. 
#
#    We cheat a little here and end each search once we have sufficient
#    electoral geography for each point, so errors which arise from overlapping
#    polygons in Boundary-Line will not be detected (this would correspond to
#    one point lying in two constituencies, say). This doesn't matter too much,
#    because (a) there shouldn't be any such overlaps (and weren't when I
#    tested this exhaustively); and (b) there wouldn't be a whole lot we could
#    do even if there were.
#
# Call with three or more arguments; 
# - the first should be the name of a Postgres database (with schema already
# constructed from mapit-schema.sql)
# - the second should be the name of a .control file with BoundaryLine version
# specific instructions in it
# - the remainder being directories containing .NTF files from Boundary-Line.
# Feed postcodes from codepoint in on a pipe.
#
# For example run like this:
# cat ~/toobig/geodata-mysociety/codepoint-2004-11/*.csv | ./process_boundary_line mapit boundaryline-2005-05.control ~/toobig/geodata-mysociety/boundaryline-2005-05-31/boundaryline-2005-05
#
# You'll need to call create_new_generation first to make the new generation in
# the db.
#
# See http://www.mysociety.org/cgi-bin/moin.cgi/MaPitDaDemDataLoading
# for details on how to use this.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_boundary_line,v 1.29 2005-09-30 14:57:02 francis Exp $';

#
# Simple object to represent a single area.
#
package Area;

use fields qw(id area_type parts minx maxx miny maxy cx cy ons_code devolved country aaid name parent children deleted alreadyexists);

# Accessor methods
my $x = fields::new('Area');
foreach (keys %$x) {
    next if ($_ eq 'children');
    eval <<EOF;
sub $_ (\$;\$) {
    my (\$self, \$val) = \@_;
    if (\@_ == 2) {
        \$self->{$_} = \$val;
    } else {
        return \$self->{$_};
    }
}
EOF
}

# children [CHILD]
# Add a CHILD to the set of this area's children, or return the current set of
# children.
sub children ($;$) {
    my ($self, $ch) = @_;
    if (defined($ch)) {
        $self->{children}->{$ch} = $ch;
    } else {
        return grep { !$_->deleted() } values(%{$self->{children}});
    }
}

sub new ($%) {
    my ($class, %values) = @_;
    my $self = fields::new($class);
    $self->{deleted} = 0;
    $self->{alreadyexists} = 1; # whether the area should already be in the db
                                # (assume yes until told otherwise)
    foreach (keys %values) {
        $self->{$_} = $values{$_};  # syntax checks?
    }
    return bless($self, $class);
}

package main;

use strict;
require 5.8.0;

use DBI;
use DBD::Pg;
use Digest::SHA1;
use Fcntl;
use File::stat;
use Geo::OSBoundaryLine;
use IO::Handle;
use Text::LevenshteinXS;

use Common;

#
# Point-in-polygon tests. Do these in C, so that the performance isn't too
# miserable.
#
use Inline C => <<'EOF';
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* pnpoly NUM XX YY X Y
 * Does the point (X, Y) lie inside the NUM-point polygon with vertices
 * (XX[0], YY[0]) ... ? */
int pnpoly(int npol, double *xp, double *yp, double x, double y) {
    int i, j, c = 0;
    for (i = 0, j = npol - 1; i < npol; j = i++) {
        if ((((yp[i] <= y) && (y < yp[j])) ||
             ((yp[j] <= y) && (y < yp[i]))) &&
                (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
          c = !c;
    }
    return c;
}

/* Hack: pass the polygon data as packed char*, so that we don't have to unpick
 * AV/SV types. */

/* poly_area NUM DATA
 * Return the area and winding order of the NUM-point polygon with vertices
 * given by DATA. Positive return values indicate ccw winding. */
double poly_area(size_t npts, char *vv) {
    /* XXX returns double because Inline::C doesn't pick up functions which
     * return float. */
    int i;
    double a;
    for (i = 0, a = 0; i < npts; ++i) {
        double x0, y0, x1, y1;
        int j;
        memcpy(&x0, vv + i * 2 * sizeof x0, sizeof x0);
        memcpy(&y0, vv + (sizeof y0) + i * 2 * sizeof y0, sizeof y0);
        j = (i + 1) % npts;
        memcpy(&x1, vv + j * 2 * sizeof x0, sizeof x0);
        memcpy(&y1, vv + (sizeof y0) + j * 2 * sizeof y0, sizeof y0);
        a += x0 * y1 - x1 * y0;
    }
    return a / 2.;
}


/* is_point_in_poly X Y NUM DATA
 * Adapter for pnpoly. */
int is_point_in_poly(double x, double y, size_t npts, char *vv) {
    static double *xx, *yy;
    static size_t nvv;
    int i;

    if (!xx || nvv < npts) {
        xx = realloc(xx, npts * sizeof *xx);
        yy = realloc(yy, npts * sizeof *yy);
        nvv = npts;
    }

    for (i = 0; i < npts; ++i) {
        memcpy(xx + i, vv + i * 2 * sizeof(double), sizeof(double));
        memcpy(yy + i, vv + sizeof(double) + i * 2 * sizeof(double), sizeof(double));
    }

    return pnpoly(npts, xx, yy, x, y);
}

EOF

# Record the size of a double for use later.
my $doublesize = length(pack('d', 0));

my %interesting_areas = map { $_ => 1 } (
    my @interesting_areas = (
#
# Types of areas about which we care:
#
# AREA_CODE What
# --------- --------------------------------------------
 'LBO',   # London Borough
 'LBW',   # London Borough Ward

 'GLA',   # GLA
 'LAC',   # GLA Constituency

 'CTY',   # County
 'CED',   # County Electoral Division

 'DIS',   # District
 'DIW',   # District Ward

 'UTA',   # Unitary Authority
 'UTE',   # Unitary Authority Electoral Division
 'UTW',   # Unitary Authority Ward

 'MTD',   # Metropolitan District
 'MTW',   # Metropolitan District Ward

 'SPE',   # Scottish Parliament Electoral Region
 'SPC',   # Scottish Parliament Constituency

 'WAE',   # Welsh Assembly Electoral Region
 'WAC',   # Welsh Assembly Constituency

 'WMC',   # Westminster Constituency

 'EUR',   # European Region

 'CPC'    # Civil Parish
    )
);

# Areas for which we compute parentage, and their parent types.
my %parentmap = qw(
        CED CTY
        DIW DIS
        LBW LBO
        MTW MTD
        UTW UTA
        UTE UTA
    );
# Can't list CPC (parish) here, because a CPC may have either a DIS or UTA
# parent.

my %childmap;
foreach (keys %parentmap) {
    $childmap{$parentmap{$_}}->{$_} = 1;
}

# But put CPC in here so that we can pick up parents of CPCs at load time.
$childmap{DIS}->{CPC} = 1;
$childmap{UTA}->{CPC} = 1;

# @shapes
# List of Area objects for each area we're interested in.
my @shapes;
my %onscode_to_shape;
my %area_type_to_shape;

# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;

die "arguments are Postgres database name, control file, and directories containing NTF files" unless (@ARGV > 2);
my $dbname = shift(@ARGV);
my $controlfile = shift(@ARGV);
if (!defined(do $controlfile)) {
    die "$controlfile: " . ($! || $@);
} elsif (!exists(&control_function)) {
    die "$controlfile: does not declare control_function(...)";
}

# Open database.
my $dbh = DBI->connect("dbi:Pg:dbname=$dbname", 'mapit', '', { AutoCommit => 0, RaiseError => 1, PrintWarn => 0, PrintError => 0 });
my $generation = $dbh->selectrow_array('select id from new_generation');
die "no new generation available" if (!defined($generation));

# Pass 1:
# Process all the directories of NTF files, saving their coordinates and
# recording area names etc. in memory.
foreach my $dir (@ARGV) {
    print STDERR "\r$dir\n";
    foreach (glob("$dir/*.[Nn][Tt][Ff]")) {
        printf STDERR "\r%s (%.2fMB) ", $_, stat($_)->size() / (1024.*1024);
        my $ntf = new Geo::OSBoundaryLine::NTFFile($_);
        print STDERR "loaded.\n";

        # Within each file, cache a list of collection ID to area object. We
        # use this to determine area parents at load time.
        my %collectid_to_area;
        my %collectid_to_parent_collectid;

        # Each administrative area will be represented by at least one
        # collection-of-features. So we go through all the collections and
        # collect all the associated shapes for processing. But collections
        # also contain child areas (e.g. a DIS collection will contain all
        # the DIW collections for its contained wards), so we don't recurse
        # down.
        foreach my $collectid (keys %{$ntf->{collections}}) {
            my $C = $ntf->{collections}->{$collectid};
            my ($area_type, $ons_code, $aaid, $name) = map { $C->attributes()->{$_} } qw(area_type ons_code admin_area_id name);

            next unless (defined($area_type) && exists($interesting_areas{$area_type}));

            # Detached subparts of administrative areas are named with a
            # suffix "(DET NO n)". Remove it.
            $name =~ s#\(DET( NO \d+|)\)\s*##gi;
            $name =~ s#\s+$##;

            # Bounding rectangle of this shape.
            my ($minx, $miny, $maxx, $maxy) = (1e8, 1e8, -1e8, -1e8);

            # List of [sense, packed polygon data].
            my @parts = ( );

            # For each part, obtain a list of vertices and update the bounding
            # rectangle.
            my ($vx, $vy);
            foreach my $part ($C->flatten(1)) {
                my ($poly, $sense) = @$part;
                my @verts = $poly->vertices();

                # save a vertex coordinate
                ($vx, $vy) = @{$verts[0]} unless (defined($vx));
                foreach (@verts) {
                    my ($x, $y) = @$_;
                    $minx = $x if ($x < $minx);
                    $maxx = $x if ($x > $maxx);
                    $miny = $y if ($y < $miny);
                    $maxy = $y if ($y > $maxy);
                }

                my $polydata = pack('d*', map { @$_ } @verts);
                my $area = 0; # XXX area including winding
                push(@parts, [$sense, $polydata, $area]);
                @verts = ( );
            }

            # Determine whether this is a new shape or a new part of a previous
            # shape.
            my $row;
            if (defined($ons_code) && exists($onscode_to_shape{$ons_code})) {
                $row = $onscode_to_shape{$ons_code};
                if ($name ne $row->name()) {
                    print STDERR "\rONS code $ons_code is used for '", $row->name(), "' and for '$name'\n";
                    undef $row;
                } else {
                    print STDERR "\rsecond shape for ONS code $ons_code; combining\n";
                }
            }

            if (!defined($row) && exists($aaid_to_shape{$area_type . $aaid})) {
                $row = $aaid_to_shape{$area_type . $aaid};
                if ($name ne $row->name()) {
                    print STDERR "\radmin area id $aaid is used for ${area_type}s '", $row->name(), "' and for '$name'\n";
                    undef $row;
                } else {
                    print STDERR "\rsecond shape for admin area id $aaid; combining\n";
                }
            }

            if (!defined($row)) {
                # New shape. Compute once-only values and save the thing.

                # We need to identify a single point inside the polygon. This
                # is used to find the areas which enclose this area in the case
                # where that cannot be computed by other means (e.g. ONS code).
                # XXX finding the centroid would be better!
                # XXX this is actually broken, since a point inside this
                # polygon might actually lie in a hole. In principle we should
                # move this to later, when all the parts for this shape have
                # been assembled.
                my ($cx, $cy);
                do {
                    $cx = $vx + rand(20) - 10;
                    $cy = $vy + rand(20) - 10;
                } while (!is_point_in_poly($cx, $cy, length($parts[0]->[1]) / (2 * $doublesize), $parts[0]->[1]));

                # Determine areas covered by devolved assemblies using
                # Euro-regions, which are coterminous with them.
                my $devolved;
                if ($area_type eq 'EUR') {
                    $devolved = 'E';
                    if ($name =~ /London/) {
                        $devolved = 'L';
                    } elsif ($name =~ /Scotland/) {
                        $devolved = 'S';
                    } elsif ($name =~ /Wales/) {
                        $devolved = 'W';
                    }
                }

                $row = new Area(
                                area_type => $area_type,
                                ons_code => $ons_code,
                                devolved => $devolved,
                                aaid => $aaid,
                                name => $name,
                                parts => \@parts,
                                minx => $minx,
                                miny => $miny,
                                maxx => $maxx,
                                maxy => $maxy,
                                cx => $cx,
                                cy => $cy,
                            );
                
                $onscode_to_shape{$ons_code} = $row if (defined($ons_code));
                $aaid_to_shape{$area_type . $aaid} = $row;
                push(@{$area_type_to_shape{$area_type}}, $row);

                push(@shapes, $row);
                STDERR->printf("\rreading shapes: %d", scalar(@shapes));
            } else {
                # Shape already exists. Form union of its parts and ours.
                print STDERR "adding collection to '", $row->name(), "'\n";
                push(@{$row->parts()}, @parts);
                $row->minx($minx) if ($minx < $row->minx());
                $row->maxx($maxx) if ($maxx > $row->maxx());
                $row->miny($miny) if ($miny < $row->miny());
                $row->maxy($maxy) if ($maxy > $row->maxy());
            }

            $collectid_to_area{$C->id()} = $row;

            # If this is an area for which we maintain a parent/child mapping,
            # then go through each of its parts linking them up appropriately.
            if (exists($childmap{$area_type})) {
                foreach my $part ($C->parts()) {
                    # Only consider child collections which are of the
                    # appropriate type to be children of this area.
                    next unless ($part->isa("Geo::OSBoundaryLine::CollectionOfFeatures")
                                    && exists($childmap{$area_type}->{$part->attributes()->area_type()}));

                    # Don't actually match up the parent and child rows here as
                    # we may not have seen all the referenced IDs yet. Save a
                    # link which we process later.
                    die "#" . $part->id() . " already has a parent, #$collectid_to_parent_collectid{$part->id()}, not " . $C->id() . "\n"
                        if (exists($collectid_to_parent_collectid{$part->id()}) && $collectid_to_parent_collectid{$part->id()} ne $C->id());
                    $collectid_to_parent_collectid{$part->id()} = $C->id();
                }
            }
        }

        # Now use the map of parent collection IDs to fix up the parent/child
        # mapping.
        print STDERR "\n";
        foreach my $child (keys %collectid_to_parent_collectid) {
            my $parent = $collectid_to_parent_collectid{$child};
            die "child collection ID #$child does not exist but was referenced by another area" if (!exists($collectid_to_area{$child}));
            $collectid_to_area{$child}->parent($collectid_to_area{$parent});
            $collectid_to_area{$parent}->children($collectid_to_area{$child});
            printf STDERR "%s lies inside %s\n", $collectid_to_area{$child}->name(), $collectid_to_area{$parent}->name();
        }

        undef $ntf;
    }
}

STDERR->printf("\rreading shapes: %d total\n", scalar(@shapes));

# Stick the shapes into buckets for a set of grid squares.
my $tilesize = 1000;   # 1km buckets
my $tiles = [ ];

# is_point_in_bucket X Y EASTING NORTHING
# Does the point (EASTING, NORTHING) lie in the bucket (X, Y)?
sub is_point_in_bucket ($$$$) {
    my ($x, $y, $E, $N) = @_;
    return (int($E / $tilesize) == $x and int($N / $tilesize) == $y);
}

# is_point_in_shape SHAPE EASTING NORTHING
# SHAPE is a row from @shapes or whatever; EASTING and NORTHING are the
# coordinates of the point.
sub is_point_in_shape ($$$) {
    my ($S, $E, $N) = @_;
    
    # Bounding box.
    return 0 if ($S->minx() > $E or $S->maxx() < $E or $S->miny > $N or $S->maxy() < $N);

    my $res = 0;
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        $res += $sense if (is_point_in_poly($E, $N, length($vv) / (2 * $doublesize), $vv));
    }
    warn "area '", $S->name(), "' coords ($E, $N) result is $res" unless ($res == 0 || $res == 1);
unless ($res == 0 || $res == 1) {
    my $n = $S->name();
    $n =~ s/ /_/g;
    print STDERR "writing sense +1 areas to /tmp/$n=+1\n";
    print STDERR "writing sense -1 areas to /tmp/$n=-1\n";
    open(P, ">/tmp/$n=+1");
    open(N, ">/tmp/$n=-1");
print STDERR "  ... shape has ", scalar(@{$S->parts()}), " parts\n";
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        my @pp = unpack('d*', $vv);
print STDERR "  ... part sense $sense ", length($vv) / (2 * $doublesize), " vertices\n";
        for (my $i = 0; $i < @pp; $i += 2) {
            if ($sense > 0) {
                print P "$pp[$i] $pp[$i + 1]\n";
            } else {
                print N "$pp[$i] $pp[$i + 1]\n";
            }
        }
        if ($sense > 0) {
            print P "\n\n";
        } else {
            print N "\n\n";
        }
    }
    close(P);
    close(N);
}
    return 1 if ($res > 0);
}

# find_containing_areas EASTING NORTHING [HINTS]
# Return a list of all areas contain the point (EASTING, NORTHING). HINTS is an
# optional hash of area type to containing area; if specified, these areas will
# be tried first before an exhastive search for areas containing the point.
my ($total_shape_tests, $total_queries) = (0, 0);
sub find_containing_areas ($$;$) {
    my ($E, $N, $hints) = @_;
    $total_queries++;

    my %found;
    my %count = map { $_ => 0 } @interesting_areas;
    my %only;

    # Count number of areas of each type.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if ($S->deleted());
        ++$count{$S->area_type()};
        $only{$S->area_type()} = $S;
    }

    # Short-circuit interiors of certain areas. Each point must be in exactly
    # one WMC and EUR.
    foreach (qw(WMC EUR)) {
        if ($count{$_} == 1) {
            $found{$_} = $only{$_};
        }
    }

    # Consider types of local government at (roughly) county level. If we find
    # only one, then we can cheat a bit.
    my @locals = qw(LBO CTY UTA MTD);
    my $sum = 0;
    map { $sum += $count{$_} } @locals;
    if ($sum == 1) {
        # Only one type of contained local government region. We may be able to
        # short-circuit searches for contained regions.
        my ($lty) = grep { $count{$_} == 1 } @locals;
        $found{$lty} = $only{$lty};
        my %contents = (
                LBO => [qw(LBW LAC GLA)],
                CTY => [qw(CED DIS DIW)],
                UTA => [qw(UTE UTW)],
                MTD => [qw(MTW)]
            );
        foreach (@{$contents{$lty}}) {
            $found{$_} = $only{$_} if ($count{$_} == 1);
        }
    }

    # Try hinted points.
    if (defined($hints)) {
        foreach my $S (grep { defined($_) and !exists($found{$_->area_type()}) } values %$hints) {
            next if ($S->deleted());
            ++$total_shape_tests;
            $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
        }
    }

    # Devolved assemblies. These cover areas which correspond to Euro-areas.
    if (exists($found{EUR})) {
        if ($found{EUR}->devolved() eq 'L') {
            $found{LAC} = $only{LAC} if ($count{LAC} == 1);
            $found{GLA} = $only{GLA} if ($count{GLA} == 1);
        } elsif ($found{EUR}->devolved() eq 'S') {
            $found{SPC} = $only{SPC} if ($count{SPC} == 1);
            $found{SPE} = $only{SPE} if ($count{SPE} == 1);
        } elsif ($found{EUR}->devolved() eq 'W') {
            $found{WAC} = $only{WAC} if ($count{WAC} == 1);
            $found{WAE} = $only{WAE} if ($count{WAE} == 1);
        }
    }

    # Now the slow way.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if ($S->deleted());
        next if (exists($found{$S->area_type()}));  # only care about one shape of each type.
        next if ($S->area_type() eq 'CPC');         # don't care about parishes at this stage
        ++$total_shape_tests;
        $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
    }

    return %found;
}

# Pass 2:
# Assign shapes to buckets. We do this by "approximate polygon rasterisation".
# Obviously the polygons from the shapefiles aren't convex, but we pretend that
# they are and put the shape in each bucket within a rough convex hull of the
# polygon's vertices. This must be done separately for each part, since shapes
# may have several disconnected convex parts (e.g. islands).
my @assigned_to_buckets;
sub assign_shapes_to_buckets () {
    my $n = 0;
    my $i = -1;
    foreach my $S (@shapes) {
        ++$i;
        ++$n;
        next if ($assigned_to_buckets[$i]);
        $assigned_to_buckets[$i] = 1;
        # Add the buckets in which vertices of the shape lie.
        foreach my $part (@{$S->parts()}) {
            my ($minx, $maxx);
            my @miny = ( );
            my @maxy = ( );
        
            # Don't rasterise holes.
            next if ($part->[0] == -1);
            my @vv = unpack('d*', $part->[1]);

            my ($ox, $oy);
            # NB: must close polygon
            for (my $i = 0; $i <= @vv; $i += 2) {
                my ($E, $N) = ($vv[$i % @vv], $vv[($i + 1) % @vv]);
                
                my ($x, $y) = (int($E / $tilesize), int($N / $tilesize));

                # Cope with the case where we've moved >1 tile horizontally.
                if (defined($ox) and $ox != $x and abs($ox - $x) > 1) {
                    my ($a, $b) = sort($ox, $x);
                    my ($A, $B) = sort($oy, $y);
                    for (my $i = $a; $i <= $b; ++$i) {
                        $miny[$i] = $A if (!defined($miny[$i]) || $A < $miny[$i]);
                        $maxy[$i] = $B if (!defined($maxy[$i]) || $B > $maxy[$i]);
                    }
                }

                $minx = $x if (!defined($minx) || $x < $minx);
                $maxx = $x if (!defined($maxx) || $x > $maxx);

                $miny[$x] = $y if (!defined($miny[$x]) || $y < $miny[$x]);
                $maxy[$x] = $y if (!defined($maxy[$x]) || $y > $maxy[$x]);
                
                $ox = $x;
                $oy = $y;
            }

            if (!defined($minx) || !defined($maxx)) {
                print STDERR "\r[2Kshape '", $S->name(), "' has no vertices\n";
                next;
            }

            # Fill the buckets between the shape bounds.
            my (@miny2, @maxy2);
            for (my $x = $minx; $x <= $maxx; ++$x) {
                die "no \$miny[$x]" unless (defined($miny[$x]));
                die "no \$maxy[$x]" unless (defined($maxy[$x]));
                $miny2[$x] = $miny[$x];
                $maxy2[$x] = $maxy[$x];
                for (my $X = $x - 1; $X <= $x + 1; ++$X) {
                    next if ($X < $minx || $X > $maxx);
                    $miny2[$x] = $miny[$X] if ($miny[$X] < $miny2[$x]);
                    $maxy2[$x] = $maxy[$X] if ($maxy[$X] > $maxy2[$x]);
                }
            }

            for (my $x = $minx; $x <= $maxx; ++$x) {
                for (my $y = $miny2[$x]; $y <= $maxy2[$x]; ++$y) {
                    push(@{$tiles->[$x]->[$y]}, $S);
                }
            }
        }
        STDERR->printf("\rfilling buckets: %d/%d shapes", $n, scalar(@shapes)) if (0 == ($n % 100));
    }
    STDERR->printf("\rfilling buckets: %d/%d shapes\n", $n, scalar(@shapes));
}

assign_shapes_to_buckets();

# Pass 3:
# Compute area parents for those which should have parents.
#
# There are several ways to do this. Firstly, where an area has an ONS code,
# the parent's ONS code will be a prefix of that code. So we can search for the
# area that way. Secondly, Boundary Line codes parent areas as collections of
# features which include the child areas. And thirdly we can search for the
# areas which contain a point within the child area, and pick out the result of
# the appropriate type.
print STDERR "finding parent areas... ";

$total_queries = 1 if ($total_queries == 0);
my $n = 0;
foreach my $S (@shapes) {
    ++$n;
    STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes; total p-in-p tests: %d; average tests/query = %f", $n, scalar(@shapes), $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));

    my $needparent = ($S->area_type() eq 'CPC' || exists($parentmap{$S->area_type()})) && !defined($S->parent());

    # Even areas which do not have a proper parent need to have a country.
    my $country = undef;

    # If this shape has a proper ONS code, use it to locate its parent and
    # country.
    my $parent = undef;
    my $ptype = $parentmap{$S->area_type()};
    if (defined($S->ons_code())) {
        if ($needparent) {
            my $newcode;
            if ($S->area_type() eq 'CPC') {
                # Parishes may be children of DIS or UTA, and their ONS codes
                # are three characters longer than their parents'.
                $newcode = substr($S->ons_code(), 0, length($S->ons_code()) - 3);
                $parent = $onscode_to_shape{$newcode};
                die "parish " . $S->name() . " #" . $S->ons_code() . " lacks a parent (should have ONS code #$newcode)"
                    unless (defined($parent));
            } else {
                $newcode = substr($S->ons_code(), 0, length($S->ons_code()) - 2);
                if (exists($onscode_to_shape{$newcode})) {
                    my $s = $onscode_to_shape{$newcode};
                    $parent = $s if ($s->area_type() eq $ptype);
                }
            }
        }

        # XXX I am assuming that ONS codes which begin '00N' are all in Wales,
        # and those which begin '00Q' or '00R' are all in Scotland. This is
        # true of SNAC 2003, and I assume will be in future too.
        if ($S->ons_code() =~ m#^00N#) {
            $country = 'W';
        } elsif ($S->ons_code() =~ m#^00[QR]#) {
            $country = 'S';
        } else {
            $country = 'E';
        }
    }

    # Otherwise we know that certain types of shapes exist only in specific
    # countries.
    my %area_type_country = (
            CED => 'E',
            CTY => 'E',
            DIW => 'E',
            DIS => 'E',
            MTW => 'E',
            MTD => 'E',
            
            LBW => 'L',
            LBO => 'L',
            LAC => 'L',
            GLA => 'L',
            
            SPE => 'S',
            SPC => 'S',

            WAE => 'W',
            WAC => 'W'
        );

    $country = $area_type_country{$S->area_type()} if (!defined($country) and exists($area_type_country{$S->area_type()}));
    
    # Otherwise do it the slow way.
    if (!defined($country) or ($needparent && !defined($parent))) {
        my %areas = find_containing_areas($S->cx(), $S->cy());
        if ($needparent and !defined($parent)) {
            if (exists($areas{$ptype})) {
                $parent = $areas{$ptype};
            } else {
                warn $S->area_type() . " shape '", $S->name(), "' has no $ptype parent\n" unless (defined($parent));
            }
        }
        if (!defined($country)) {
            my $euro = $areas{EUR};
            if (!defined($euro)) {
                warn $S->area_type(), " shape '", $S->name(), "' is not in a Euro-area\n";
            } else {
                # Devolved assembly info.
                $country = $euro->devolved();
                $country = 'E' if ($country eq 'L');
            }
        }
    }

    # Record both parent and child.
    if ($needparent && defined($parent)) {
        $S->parent($parent);
        $parent->children($S);
    }
    $S->country($country) if (defined($country));
}
STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes\n", $n, scalar(@shapes));

#
# Now we need to:
#
# - identify which areas are new (i.e., the results of boundary changes etc.);
# 
# - construct new areas to incorporate boundary changes which are not yet
#   shown in the data; and
#
# Accordingly, process control file commands.
#

control_function(\@shapes, \%onscode_to_shape, \%area_type_to_shape);

# Having done this, we need to rasterise the new shapes.
assign_shapes_to_buckets();

#
# Last step: where an area corresponds to an area which was already in the
# data, identify the ID of the old area so that we can keep it for the new
# area.
#

# match_db_areas AREAS CONDITION
# AREAS is a list of areas, and CONDITION a where-clause fragment for selecting
# from the database a superset of areas which should match them. On success,
# annotates each of the AREAS with the appropriate ID; on failure, dies.
sub match_db_areas ($$) {
    my ($areas, $condition) = @_;

    my $g = current_generation($dbh);
    my $s = "select id, parent_area_id, unit_id, ons_code, type, name from area, area_name where area.id = area_name.area_id and name_type = 'O' and ($g >= generation_low and $g <= generation_high) and ($condition)";
    my $aa = $dbh->selectall_hashref($s, 'id');

    if (scalar(keys(%$aa)) < @$areas) {
        print STDERR "condition = $condition\ngot " . scalar(keys(%$aa)) . " from db, but have " . scalar(@$areas) . " to match";
        print STDERR "read in:\n";
        foreach (sort { $a->name() cmp $b->name() } @$areas) {
            print STDERR "    ", $_->name(), "\n";
        }
        print STDERR "in database:\n";
        foreach (sort { $a->{name} cmp $b->{name} } values %$aa) {
            print STDERR "    $_->{name}\n";
        }
        die "oops\n";
    }

    foreach my $A (@$areas) {
        my @i = sort { Text::LevenshteinXS::distance($A->name(), $a->{name}) cmp Text::LevenshteinXS::distance($A->name(), $b->{name}) } values(%$aa);
        die "closest match for '" . $A->name() . "', '" . $i[0]->{name} . "', is not similar enough"
            if (Text::LevenshteinXS::distance($A->name(), $i[0]->{name}) > length($A->name()) / 10);
        print STDERR $A->name(), " -> $i[0]->{name}\n";
        $A->id($i[0]->{id});
        delete($aa->{$A->id()});
    }
}

print STDERR "Finding existing database rows for areas...\n";

# For each area type, associate names.
foreach my $area_type (grep { !exists($parentmap{$_}) && $_ ne 'CPC' } @interesting_areas) {
    print STDERR "$area_type...\n";
    my @aa = grep { $_->alreadyexists() && !$_->deleted() } @{$area_type_to_shape{$area_type}};
    match_db_areas(\@aa, 'type = ' . $dbh->quote($area_type));
    
    # Now consider these shapes' children.
    if (exists($childmap{$area_type})) {
        foreach my $S (@aa) {
            print "--- children for ", $S->name(), "\n";
            my @children = grep { $_->alreadyexists() && !$_->deleted() && $_->area_type() ne 'CPC' } $S->children();
            match_db_areas(\@children, 'parent_area_id = ' . $S->id());
        }
    }
}

# Now write the areas into the database, either doing updates to generations
# and names where the areas already exist, or creating them anew where they do
# not.
$n = 0;
foreach my $S ((grep { !defined($_->parent()) } @shapes), (grep { defined($_->parent()) } @shapes)) {
    ++$n;
    next if ($S->deleted() || $S->area_type() eq 'CPC');
    my $id = $S->id();
    if (defined($id)) {
        # existing area
        $dbh->do("delete from area_name where area_id = ? and name_type = 'O'", {}, $id);
        $dbh->do("insert into area_name (area_id, name_type, name) values (?, 'O', ?)", {}, $id, $S->name());
        $dbh->do("update area set generation_high = ? where id = ?", {}, $generation, $id);
    } else {
        # new area
        $id = $dbh->selectrow_array("select nextval('area_id_seq')");
        $S->id($id);

        if ($S->ons_code()) {
            my $a = $dbh->selectrow_hashref('select * from area where ons_code = ?', {}, $S->ons_code());
            if (defined($a)) {
                my $n = $dbh->selectrow_array("select name from area_name where area_id = ? and name_type = 'O'", {}, $a->{id});
                die "was about to insert area '", $S->name(), "' with ONS Code ", $S->ons_code(), ", but an area #$a->{id} '$n' already exists\n";
            }
        }
 
        $dbh->do("insert into area (
                            id,
                            parent_area_id,
                            unit_id, ons_code,
                            type, country,
                            generation_low, generation_high
                        ) values (
                            ?,
                            ?,
                            ?, ?,
                            ?, ?,
                            ?, ?
                        )", {},
                            $id,
                            defined($S->parent()) ? $S->parent()->id() : undef,
                            $S->aaid(), $S->ons_code(),
                            $S->area_type(), $S->country(),
                            $generation, $generation);

        $dbh->do("insert into area_name (area_id, name_type, name) values (?, 'O', ?)", {}, $S->id(), $S->name());
    }
    printf STDERR "\rUpdating database: %d/%d shapes", $n, scalar(@shapes) if (($n % 100) == 0);
}
printf STDERR "\rUpdating database: %d/%d shapes\n", $n, scalar(@shapes);

# Reset statistics.
$total_shape_tests = $total_queries = 0;

# Read list of postcodes and coordinates, do point-in-polygon tests for each
# one.
{
    local $/ = "\r\n";
    my $n = 0;

    # Cache area result between postcode tests for speed.
    my %areas = map { $_ => undef } @interesting_areas;

    while (defined(my $line = <STDIN>)) {
        chomp $line;
        my @x = split(/,/, $line);
        
        my ($pc, $qual, $E, $N) = ($x[0], $x[1], $x[10], $x[11]);
        $pc =~ s/[" ]//g;

        next if ($pc =~ m#^BT#          # NI
                || $qual == 90);        # no coordinates
        
        %areas = find_containing_areas($E, $N, \%areas);

        # Sanity checks.
        foreach my $musthave (qw(WMC EUR)) {
            warn "no $musthave for $pc ($E, $N)\n" unless (defined($areas{$musthave}));
        }

        foreach my $bothneither ([qw(DIS DIW)], [qw(CTY CED)], [qw(GLA LAC)], [qw(LBO LBW)], [qw(MTD MTW)], [qw(SPE SPC)], [qw(WAE WAC)], [qw(DIS CTY)]) {
            # Locations in the Scilly Isles have a county ("Isles of Scilly")
            # but no CEDs.
            next if ($bothneither->[0] eq 'CTY' and $pc =~ m#^TR2#);
        
            warn "$bothneither->[0] but no $bothneither->[1] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[0]}) and !defined($areas{$bothneither->[1]}));
            warn "$bothneither->[1] but no $bothneither->[0] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[1]}) and !defined($areas{$bothneither->[0]}));
        }

        foreach my $oneof ([qw(LBO UTA DIS MTD)], [qw(LAC SPC WAC)], [qw(CTY UTA MTA)]) {
            my @a = grep { defined($areas{$_}) } @$oneof;
            warn join(" ", @a) . " for $pc ($E, $N)\n" if (@a > 1);
        }
       
        my $pcid = get_postcode_id($dbh, $pc, $E, $N);
        $dbh->do('delete from postcode_area where postcode_id = ?', {}, $pcid);
        foreach my $S (grep { defined($_) } values %areas) {
            next if ($S->deleted() || $S->area_type() eq 'CPC');
            $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $S->id());
        }

        ++$n;
        if (0 == ($n % 100)) {
            $dbh->commit();
            STDERR->printf("\r%d postcodes (%s); total p-in-p tests: %d; average tests/query = %f", $n, $pc, $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));
        }
    }
    STDERR->printf("\r[2K%d postcodes\n", $n);
}

$dbh->commit();
$dbh->disconnect();
