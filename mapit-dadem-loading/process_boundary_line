#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# process_boundary_line:
# Load the Boundary-Line polygons into memory, and compare postcodes (e.g.
# from CodePoint) against their areas, to form the database used by MaPit.
#
# The strategy here is as follows: For each area, we read each polygon from the
# OS-supplied NTF files. We represent these in memory as packed arrays of
# doubles (otherwise the memory requirement exceeded poor caesious's little
# mind). This also makes use of the C pnpoly function (see below) more
# convenient, which speeds things up a little. We assemble a "spatial hash"
# which maps square regions (presently of size 1km) to the
# electoral/administrative areas which overlap them. Now we are ready to
# compute point-polygon intersections. We read the CodePoint data from the
# OS-supplied CSV files, ignoring data for Northern Ireland (processed
# separately, since Boundary-Line only covers GB) and determine the locations
# in which each point lies. We cheat a little here and end each search once we
# have sufficient electoral geography for each point, so errors which arise
# from overlapping polygons in Boundary-Line will not be detected (this would
# correspond to one point lying in two constituencies, say). This doesn't
# matter too much, because (a) there shouldn't be any such overlaps (and
# weren't when I tested this exhaustively); and (b) there wouldn't be a whole
# lot we could do even if there were.
#
# Call with two or more arguments; the first should be the name of a Postgres
# database (with schema already constructed from mapit-schema.sql) and the
# remainder being directories containing .shp files from Boundary-Line.
# Feed postcodes from codepoint in on a pipe.
#
# See http://www.mysociety.org/cgi-bin/moin.cgi/MaPitDaDemDataLoading
# for details.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_boundary_line,v 1.17 2005-08-08 12:02:34 chris Exp $';

use strict;
require 5.8.0;

use DBI;
use DBD::Pg;
use Digest::SHA1;
use Fcntl;
use File::stat;
use Geo::OSBoundaryLine;
use IO::Handle;

use Common;

#
# Point-in-polygon tests. Do these in C, so that the performance isn't too
# miserable.
#
use Inline C => <<'EOF';
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

/* pnpoly NUM XX YY X Y
 * Does the point (X, Y) lie inside the NUM-point polygon with vertices
 * (XX[0], YY[0]) ... ? */
int pnpoly(int npol, double *xp, double *yp, double x, double y) {
    int i, j, c = 0;
    for (i = 0, j = npol - 1; i < npol; j = i++) {
        if ((((yp[i] <= y) && (y < yp[j])) ||
             ((yp[j] <= y) && (y < yp[i]))) &&
                (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
          c = !c;
    }
    return c;
}

/* Hack: pass the polygon data as packed char*, so that we don't have to unpick
 * AV/SV types. */

/* poly_area NUM DATA
 * Return the area and winding order of the NUM-point polygon with vertices
 * given by DATA. Positive return values indicate ccw winding. */
double poly_area(size_t npts, char *vv) {
    /* XXX returns double because Inline::C doesn't pick up functions which
     * return float. */
    int i;
    double a;
    for (i = 0, a = 0; i < npts; ++i) {
        double x0, y0, x1, y1;
        int j;
        memcpy(&x0, vv + i * 2 * sizeof x0, sizeof x0);
        memcpy(&y0, vv + (sizeof y0) + i * 2 * sizeof y0, sizeof y0);
        j = (i + 1) % npts;
        memcpy(&x1, vv + j * 2 * sizeof x0, sizeof x0);
        memcpy(&y1, vv + (sizeof y0) + j * 2 * sizeof y0, sizeof y0);
        a += x0 * y1 - x1 * y0;
    }
    return a / 2.;
}


/* is_point_in_poly X Y NUM DATA
 * Adapter for pnpoly. */
int is_point_in_poly(double x, double y, size_t npts, char *vv) {
    static double *xx, *yy;
    static size_t nvv;
    int i;

    if (!xx || nvv < npts) {
        xx = realloc(xx, npts * sizeof *xx);
        yy = realloc(yy, npts * sizeof *yy);
        nvv = npts;
    }

    for (i = 0; i < npts; ++i) {
        memcpy(xx + i, vv + i * 2 * sizeof(double), sizeof(double));
        memcpy(yy + i, vv + sizeof(double) + i * 2 * sizeof(double), sizeof(double));
    }

    return pnpoly(npts, xx, yy, x, y);
}

EOF

my $doublesize = length(pack('d', 0));

my %interesting_areas = map { $_ => 1 } (
    my @interesting_areas = (
#
# Types of areas about which we care:
#
# AREA_CODE What
# --------- --------------------------------------------
 'LBO',   # London Borough
 'LBW',   # London Borough Ward

 'GLA',   # GLA
 'LAC',   # GLA Constituency

 'CTY',   # County
 'CED',   # County Electoral Division

 'DIS',   # District
 'DIW',   # District Ward

 'UTA',   # Unitary Authority
 'UTE',   # Unitary Authority Electoral Division
 'UTW',   # Unitary Authority Ward

 'MTD',   # Metropolitan District
 'MTW',   # Metropolitan District Ward

 'SPE',   # Scottish Parliament Electoral Region
 'SPC',   # Scottish Parliament Constituency

 'WAE',   # Welsh Assembly Electoral Region
 'WAC',   # Welsh Assembly Constituency

 'WMC',   # Westminster Constituency

 'EUR'    # European Region
    )
);

# @shapes
# List of [ unique ID, area code, shape, min_x, max_x, min_y, max_y, cx, cy, ons_code ] for each
# area we're interested in.
my @shapes;
my %onscode_to_shape;

die "arguments are Postgres database name and directories containing NTF files" unless (@ARGV > 1);
my $dbname = shift(@ARGV);

# Open database.
my $dbh = DBI->connect("dbi:Pg:dbname=$dbname", 'mapit', '', { AutoCommit => 0, RaiseError => 1, PrintWarn => 0, PrintError => 0 });
my $generation = $dbh->selectrow_array('select id from new_generation');
die "no new generation available" if (!defined($generation));

# Pass 1:
# Process all the directories of NTF files, saving their coordinates and
# recording area names etc. in memory.

# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;
use Data::Dumper;
foreach my $dir (@ARGV) {
    print STDERR "\r$dir\n";
    foreach (sort { stat($b)->size() <=> stat($a)->size() } glob("$dir/*.[Nn][Tt][Ff]")) {
        printf STDERR "\r%s (%.2fMB) ", $_, stat($_)->size() / (1024.*1024);
        my $ntf = new Geo::OSBoundaryLine::NTFFile($_);
        print STDERR "loaded.\n";

        # Each administrative area will be represented by a single
        # collection-of-features. So we can go through all the
        # collections-of-features and collect all the associated shapes for
        # processing.
        foreach my $C (values %{$ntf->{collections}}) {
            my ($area_type, $ons_code, $aaid, $name) = map { $C->attributes()->{$_} } qw(area_type ons_code admin_area_id name);

            next unless (defined($area_type) && exists($interesting_areas{$area_type}));

            # Bounding rectangle of this shape.
            my ($minx, $miny, $maxx, $maxy) = (1e8, 1e8, -1e8, -1e8);

            # List of [sense, packed polygon data].
            my @parts = ( );

            # For each part, obtain a list of vertices and update the bounding
            # rectangle.
            my ($vx, $vy);
            foreach my $part ($C->flatten()) {
                my ($poly, $sense) = @$part;
                my @verts = $poly->vertices();

                # save a vertex coordinate
                ($vx, $vy) = @{$verts[0]} unless (defined($vx));
                foreach (@verts) {
                    my ($x, $y) = @$_;
                    $minx = $x if ($x < $minx);
                    $maxx = $x if ($x > $maxx);
                    $miny = $y if ($y < $miny);
                    $maxy = $y if ($y > $maxy);
                }

                my $polydata = pack('d*', map { @$_ } @verts);
                my $area = 0; # XXX
                push(@parts, [$sense, $polydata, $area]);
                @verts = ( );
            }

            # Detached subparts of administrative areas are named with a
            # suffix "(DET NO n)". Remove it.
            $name =~ s#\(DET( NO \d+|)\)##g;
            $name =~ s#\s+$##;

            # Determine whether this is a new shape or a new part of a previous
            # shape.
            my $row;
            if (defined($ons_code) && exists($onscode_to_shape{$ons_code})) {
                $row = $onscode_to_shape{$ons_code};
                print STDERR "second shape for ONS code $ons_code; combining\n";
                die "ONS code $ons_code is used for '$row->[12]' and for '$name'\n"
                    if ($name ne $row->[12]);
            }

            if (!defined($row) && exists($aaid_to_shape{$aaid})) {
                $row = $aaid_to_shape{$aaid};
                    if ($name ne $row->[12]) {
                warn "admin area id $aaid is used for '$row->[12]' and for '$name'\n";
                $row = undef;}
            }

            if (!defined($row)) {
                # New shape. Compute once-only values and save the thing.

                # We need to identify a single point inside the polygon. This
                # is used to find the areas which enclose this area in the case
                # where that cannot be computed by other means (e.g. ONS code).
                # XXX finding the centroid would be better!
                my ($cx, $cy);
                do {
                    $cx = $vx + rand(20) - 10;
                    $cy = $vy + rand(20) - 10;
                } while (!is_point_in_poly($cx, $cy, length($parts[0]->[1]) / (2 * $doublesize), $parts[0]->[1]));

                # Determine areas covered by devolved assemblies using
                # Euro-regions, which are coterminous with them.
                my $devolved;
                if ($area_type eq 'EUR') {
                    $devolved = 'E';
                    if ($name =~ /London/) {
                        $devolved = 'L';
                    } elsif ($name =~ /Scotland/) {
                        $devolved = 'S';
                    } elsif ($name =~ /Wales/) {
                        $devolved = 'W';
                    }
                }

                # first element is id, which we don't know yet
                #           0      1           2        3      4      5      6      7    8    9          10         11     12
                my $row = [ undef, $area_type, \@parts, $minx, $maxx, $miny, $maxy, $cx, $cy, $ons_code, $devolved, $aaid, $name ];
                $onscode_to_shape{$ons_code} = $row if (defined($ons_code));
                $aaid_to_shape{$aaid} = $row;

                push(@shapes, $row);
                STDERR->printf("\rreading shapes: %d", scalar(@shapes));
            } else {
                # Shape already exists. Form union of its parts and ours.
                print STDERR "adding collection to '$row->[12]'\n";
                push(@{$row->[2]}, @parts);
                $row->[3] = $minx if ($minx < $row->[3]);
                $row->[4] = $maxx if ($maxx > $row->[4]);
                $row->[5] = $miny if ($miny < $row->[5]);
                $row->[6] = $maxy if ($maxy > $row->[6]);
            }
        }

        undef $ntf;
    }
}

STDERR->printf("\rreading shapes: %d total\n", scalar(@shapes));

# Pass 1.5:
# Assign IDs to all these areas, and save them in a database.
my $n = 0;
foreach my $row (@shapes) {
    my $parts = $row->[2];

    # Compute the geometry hash of the polygon. Consider parts in order of area
    # (counting winding), and hash the polydata. Strictly that's
    # architecture-dependent, but that doesn't matter because the data have
    # already passed through Shapelib, which treats them as binary
    # floating-point numbers.
    my $digest = new Digest::SHA1();
    foreach (sort { $parts->[$a]->[2] <=> $parts->[$b]->[2] } (0 .. scalar(@$parts) - 1)) {
        $digest->add($parts->[$_]->[1]);
    }
    $digest = $digest->hexdigest();

    # Determine the area ID for this area in the database. If this area
    # corresponds exactly to an area we already know about, recycle the ID;
    # otherwise, create a new one.
    $row->[0] = get_area_id($dbh, $row->[12], 'O', $row->[1], $row->[9], $row->[11], $digest);
    STDERR->printf("\rsaving shapes in database: %d/%d", ++$n, scalar(@shapes));
}

#$dbh->commit();


# Stick the shapes into buckets for a set of grid squares.
my $tilesize = 1000;   # 1km buckets
my $tiles = [ ];

# is_point_in_bucket X Y EASTING NORTHING
# Does the point (EASTING, NORTHING) lie in the bucket (X, Y)?
sub is_point_in_bucket ($$$$) {
    my ($x, $y, $E, $N) = @_;
    return (int($E / $tilesize) == $x and int($N / $tilesize) == $y);
}

# is_point_in_shape SHAPE EASTING NORTHING
# SHAPE is a row from @shapes or whatever; EASTING and NORTHING are the
# coordinates of the point.
sub is_point_in_shape ($$$) {
    my ($S, $E, $N) = @_;
    
    # Bounding box.
    return 0 if ($S->[3] > $E or $S->[4] < $E or $S->[5] > $N or $S->[6] < $N);

    my $res = 0;
    foreach (@{$S->[2]}) {
        my ($sense, $vv) = @$_;
        $res += $sense if (is_point_in_poly($E, $N, length($vv) / (2 * $doublesize), $vv));
    }
    warn "area $S->[0] coords ($E, $N) result is $res" unless ($res == 0 || $res == 1);
    return 1 if ($res > 0);
}

# find_containing_areas EASTING NORTHING [HINTS]
# Return a list of all shapes (in the same format as rows of @shapes) which
# contain the point (EASTING, NORTHING). HINTS is an optional hash of area type
# to containing area.
my ($total_shape_tests, $total_queries) = (0, 0);
sub find_containing_areas ($$;$) {
    my ($E, $N, $hints) = @_;
    $total_queries++;

    my %found;
    my %count = map { $_ => 0 } @interesting_areas;
    my %only;

    # Count number of areas of each type.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        ++$count{$S->[1]};
        $only{$S->[1]} = $S;
    }

    # Short-circuit interiors of certain areas. Each point must be in exactly
    # one WMC and EUR.
    foreach (qw(WMC EUR)) {
        if ($count{$_} == 1) {
            $found{$_} = $only{$_};
        }
    }

    # Consider types of local government at (roughly) county level. If we find
    # only one, then we can cheat a bit.
    my @locals = qw(LBO CTY UTA MTD);
    my $sum = 0;
    map { $sum += $count{$_} } @locals;
    if ($sum == 1) {
        # Only one type of contained local government region. We may be able to
        # short-circuit searches for contained regions.
        my ($lty) = grep { $count{$_} == 1 } @locals;
        $found{$lty} = $only{$lty};
        my %contents = (
                LBO => [qw(LBW LAC GLA)],
                CTY => [qw(CED DIS DIW)],
                UTA => [qw(UTE UTW)],
                MTD => [qw(MTW)]
            );
        foreach (@{$contents{$lty}}) {
            $found{$_} = $only{$_} if ($count{$_} == 1);
        }
    }

    # Try hinted points.
    if (defined($hints)) {
        foreach my $S (grep { defined($_) and !exists($found{$_->[1]}) } values %$hints) {
            ++$total_shape_tests;
            $found{$S->[1]} = $S if (is_point_in_shape($S, $E, $N));
        }
    }

    # Devolved assemblies. These cover areas which correspond to Euro-areas.
    if (exists($found{EUR})) {
        if ($found{EUR}->[10] eq 'L') {
            $found{LAC} = $only{LAC} if ($count{LAC} == 1);
            $found{GLA} = $only{GLA} if ($count{GLA} == 1);
        } elsif ($found{EUR}->[10] eq 'S') {
            $found{SPC} = $only{SPC} if ($count{SPC} == 1);
            $found{SPE} = $only{SPE} if ($count{SPE} == 1);
        } elsif ($found{EUR}->[10] eq 'W') {
            $found{WAC} = $only{WAC} if ($count{WAC} == 1);
            $found{WAE} = $only{WAE} if ($count{WAE} == 1);
        }
    }

    # Now the slow way.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if (exists($found{$S->[1]}));  # only care about one shape of each type.
        ++$total_shape_tests;
        $found{$S->[1]} = $S if (is_point_in_shape($S, $E, $N));
    }

    return %found;
}

# Pass 2:
# Assign shapes to buckets. We do this by "approximate polygon rasterisation".
# Obviously the polygons from the shapefiles aren't convex, but we pretend that
# they are and put the shape in each bucket within a rough convex hull of the
# polygon's vertices. This must be done separately for each part, since shapes
# may have several disconnected convex parts (e.g. islands).
$n = 0;
foreach my $S (@shapes) {
    # Add the buckets in which vertices of the shape lie.
    foreach my $part (@{$S->[2]}) {
        my ($minx, $maxx);
        my @miny = ( );
        my @maxy = ( );
    
        # Don't rasterise holes.
        next if ($part->[0] == -1);
        my @vv = unpack('d*', $part->[1]);

        my ($ox, $oy);
        # NB: must close polygon
        for (my $i = 0; $i <= @vv; $i += 2) {
            my ($E, $N) = ($vv[$i % @vv], $vv[($i + 1) % @vv]);
            
            my ($x, $y) = (int($E / $tilesize), int($N / $tilesize));

            # Cope with the case where we've moved >1 tile horizontally.
            if (defined($ox) and $ox != $x and abs($ox - $x) > 1) {
                my ($a, $b) = sort($ox, $x);
                my ($A, $B) = sort($oy, $y);
                for (my $i = $a; $i <= $b; ++$i) {
                    $miny[$i] = $A if (!defined($miny[$i]) || $A < $miny[$i]);
                    $maxy[$i] = $B if (!defined($maxy[$i]) || $B > $maxy[$i]);
                }
            }

            $minx = $x if (!defined($minx) || $x < $minx);
            $maxx = $x if (!defined($maxx) || $x > $maxx);

            $miny[$x] = $y if (!defined($miny[$x]) || $y < $miny[$x]);
            $maxy[$x] = $y if (!defined($maxy[$x]) || $y > $maxy[$x]);
            
            $ox = $x;
            $oy = $y;
        }

        if (!defined($minx) || !defined($maxx)) {
            print STDERR "\r[2Kshape #$S->[0] has no vertices\n";
            next;
        }

        # Fill the buckets between the shape bounds.
        my (@miny2, @maxy2);
        for (my $x = $minx; $x <= $maxx; ++$x) {
            die "no \$miny[$x]" unless (defined($miny[$x]));
            die "no \$maxy[$x]" unless (defined($maxy[$x]));
            $miny2[$x] = $miny[$x];
            $maxy2[$x] = $maxy[$x];
            for (my $X = $x - 1; $X <= $x + 1; ++$X) {
                next if ($X < $minx || $X > $maxx);
                $miny2[$x] = $miny[$X] if ($miny[$X] < $miny2[$x]);
                $maxy2[$x] = $maxy[$X] if ($maxy[$X] > $maxy2[$x]);
            }
        }

        for (my $x = $minx; $x <= $maxx; ++$x) {
            for (my $y = $miny2[$x]; $y <= $maxy2[$x]; ++$y) {
                push(@{$tiles->[$x]->[$y]}, $S);
            }
        }
    }

    ++$n;
    STDERR->printf("\rfilling buckets: %d/%d shapes", $n, scalar(@shapes)) if (0 == ($n % 100));
}
STDERR->printf("\rfilling buckets: %d/%d shapes\n", $n, scalar(@shapes));

# Pass 3:
# Compute area parents for those which should have parents.
print STDERR "finding parent areas... ";
my %parentmap = qw(
        CED CTY
        DIW DIS
        LBW LBO
        MTW MTD
        UTW UTA
        UTE UTA
    );
$n = 0;
foreach my $S (@shapes) {
    ++$n;
    STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes; total p-in-p tests: %d; average tests/query = %f", $n, scalar(@shapes), $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));

    my $needparent = exists($parentmap{$S->[1]});

    # Even areas which do not have a proper parent need to have a country.
    my $country = undef;

    # If this shape has a proper ONS code, use it to locate its parent and
    # country.
    my $pid = undef;
    my $ptype = $parentmap{$S->[1]};
    if (defined($S->[9])) {
        if ($needparent) {
            my $newcode = substr($S->[9], 0, length($S->[9]) - 2);
            if (exists($onscode_to_shape{$newcode})) {
                my $s = $onscode_to_shape{$newcode};
                $pid = $s->[0] if ($s->[1] eq $ptype);
            }
        }

        # XXX I am assuming that ONS codes which begin '00N' are all in Wales,
        # and those which begin '00Q' or '00R' are all in Scotland. This is
        # true of SNAC 2003, and I assume will be in future too.
        if ($S->[9] =~ m#^00N#) {
            $country = 'W';
        } elsif ($S->[9] =~ m#^00[QR]#) {
            $country = 'S';
        } else {
            $country = 'E';
        }
    }
    
    # Otherwise do it the slow way.
    if (!defined($country) or ($needparent && !defined($pid))) {
        my %areas = find_containing_areas($S->[7], $S->[8]);
        if ($needparent and !defined($pid)) {
            if (exists($areas{$ptype})) {
                $pid = $areas{$ptype}->[0];
            } else {
                warn "$S->[1] shape $S->[0] has no $ptype parent\n" unless (defined($pid));
            }
        }
        if (!defined($country)) {
            my $euro = $areas{EUR};
            if (!defined($euro)) {
                warn "$S->[1] shape $S->[0] is not in a Euro-area\n";
            } else {
                # Devolved assembly info.
                $country = $euro->[10];
                $country = 'E' if ($country eq 'L');
            }
        }
    }

    $dbh->do('update area set parent_area_id = ? where id = ?', {}, $pid, $S->[0]) if ($needparent and defined($pid));
    country($dbh, $S->[0], $country) if (defined($country));
}
$dbh->commit();
STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes\n", $n, scalar(@shapes));

# Reset statistics.
$total_shape_tests = $total_queries = 0;

# Read list of postcodes and coordinates, do point-in-polygon tests for each
# one.
{
    local $/ = "\r\n";
    my $n = 0;

    # Cache area result between postcode tests for speed.
    my %areas = map { $_ => undef } @interesting_areas;

    while (defined(my $line = <STDIN>)) {
        chomp $line;
        my @x = split(/,/, $line);
        
        my ($pc, $qual, $E, $N) = ($x[0], $x[1], $x[10], $x[11]);
        $pc =~ s/[" ]//g;

        next if ($pc =~ m#^BT#          # NI
                || $qual == 90);        # no coordinates
        
        %areas = find_containing_areas($E, $N, \%areas);

        # Sanity checks.
        foreach my $musthave (qw(WMC EUR)) {
            warn "no $musthave for $pc ($E, $N)\n" unless (defined($areas{$musthave}));
        }

        foreach my $bothneither ([qw(DIS DIW)], [qw(CTY CED)], [qw(GLA LAC)], [qw(LBO LBW)], [qw(MTD MTW)], [qw(SPE SPC)], [qw(WAE WAC)], [qw(DIS CTY)]) {
            # Locations in the Scilly Isles have a county ("Isles of Scilly")
            # but no CEDs.
            next if ($bothneither->[0] eq 'CTY' and $pc =~ m#^TR2#);
        
            warn "$bothneither->[0] but no $bothneither->[1] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[0]}) and !defined($areas{$bothneither->[1]}));
            warn "$bothneither->[1] but no $bothneither->[0] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[1]}) and !defined($areas{$bothneither->[0]}));
        }

        foreach my $oneof ([qw(LBO UTA DIS MTD)], [qw(LAC SPC WAC)], [qw(CTY UTA MTA)]) {
            my @a = grep { defined($areas{$_}) } @$oneof;
            warn join(" ", @a) . " for $pc ($E, $N)\n" if (@a > 1);
        }
       
        my $pcid = get_postcode_id($dbh, $pc, $E, $N);
        foreach my $S (grep { defined($_) } values %areas) {
            $dbh->do('delete from postcode_area where postcode_id = ? and area_id = ?', {}, $pcid, $S->[0]);
            $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $S->[0]);
        }

        ++$n;
        if (0 == ($n % 100)) {
            $dbh->commit();
            STDERR->printf("\r%d postcodes (%s); total p-in-p tests: %d; average tests/query = %f", $n, $pc, $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));
        }
    }
    STDERR->printf("\r[2K%d postcodes\n", $n);
}

$dbh->commit();
$dbh->disconnect();
