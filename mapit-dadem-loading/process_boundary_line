#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# process_boundary_line:
# Load the Boundary-Line polygons into memory, and compare postcodes (e.g.
# from CodePoint) against their areas, to form the database used by MaPit.
#
# The strategy here is as follows: 
#
# a. For each area, we read each polygon from the OS-supplied NTF/ShapeFile files. We
#    represent these in memory as packed arrays of doubles (otherwise the
#    memory requirement exceeded poor caesious's little mind). This also makes
#    use of the C pnpoly function (see below) more convenient, which speeds
#    things up a little.  
#
#    We assemble a "spatial hash" which maps square regions (presently of size
#    1km) to the electoral/administrative areas which overlap them. 
#
# b. Now we are ready to compute point-polygon intersections. We read the
#    CodePoint data from the OS-supplied CSV files, ignoring data for Northern
#    Ireland (processed separately, since Boundary-Line only covers GB) and
#    determine the locations in which each point lies. 
#
#    We cheat a little here and end each search once we have sufficient
#    electoral geography for each point, so errors which arise from overlapping
#    polygons in Boundary-Line will not be detected (this would correspond to
#    one point lying in two constituencies, say). This doesn't matter too much,
#    because (a) there shouldn't be any such overlaps (and weren't when I
#    tested this exhaustively); and (b) there wouldn't be a whole lot we could
#    do even if there were.
#
# Call with two or more arguments; 
# - the first should be the name of a .control file with BoundaryLine version
# specific instructions in it
# - the remainder being directories containing .NTF/ShapeFile files from Boundary-Line.
# Feed postcodes from codepoint in on a pipe. Specify database to
# connect to in ../conf/general.
#
# For example run like this:
# cat ~/toobig/geodata-mysociety/codepoint-2004-11/*.csv | ./process_boundary_line boundaryline-2005-05.control ~/toobig/geodata-mysociety/boundaryline-2005-05-31/boundaryline-2005-05
# cat ~/codepoint-2004-11/*.csv | ./process_boundary_line mapit boundaryline-2005-05.control ~/boundaryline-2005-05
#
# You'll need to call create_new_generation first to make the new generation in
# the db.
#
# See http://www.mysociety.org/cgi-bin/moin.cgi/MaPitDaDemDataLoading
# for details on how to use this.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_boundary_line,v 1.40 2009-12-21 17:34:01 matthew Exp $';

use strict;
require 5.8.0;

use DBI;
use DBD::Pg;
use Digest::SHA1;
use Fcntl;
use Geo::OSBoundaryLine;
use IO::Handle;
use Text::LevenshteinXS;

use Common;
use Area;
use BoundaryLine qw(%interesting_areas @interesting_areas %childmap %parentmap doublesize);
use mySociety::Polygon;

# @shapes
# List of Area objects for each area we're interested in.
my @shapes;
my %onscode_to_shape;
my %area_type_to_shape;
# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;

die "arguments are control file, and directories containing NTF or ShapeFile files" unless (@ARGV > 1);
my $controlfile = shift(@ARGV);
if ($controlfile eq '/dev/null') {
    # debugging special case
    eval 'sub control_function { };';
} else {
    if (!defined(do $controlfile)) {
        die "$controlfile: " . ($! || $@);
    } elsif (!exists(&control_function)) {
        die "$controlfile: does not declare control_function(...)";
    }
}

# Open database.
my $dbh = Common::connect_to_mapit_database();
my $generation = $dbh->selectrow_array('select id from new_generation');
die "no new generation available" if (!defined($generation));

# Pass 1:
# Process all the directories of NTF/ShapeFile files, saving their coordinates and
# recording area names etc. in memory.
foreach my $dir (@ARGV) {
    print STDERR "\r$dir\n";
    if (-d $dir) {
        foreach (glob("$dir/*.[Nn][Tt][Ff]")) {
            BoundaryLine::load_ntf_file($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
        }
        foreach (glob("$dir/*.shp")) {
            BoundaryLine::load_shapefile($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
        }
    } else {
        BoundaryLine::load_shapefile($dir, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
    }
}

STDERR->printf("\rreading shapes: %d total\n", scalar(@shapes));

# Stick the shapes into buckets for a set of grid squares.
my $tilesize = 1000;   # 1km buckets
my $tiles = [ ];

# is_point_in_bucket X Y EASTING NORTHING
# Does the point (EASTING, NORTHING) lie in the bucket (X, Y)?
sub is_point_in_bucket ($$$$) {
    my ($x, $y, $E, $N) = @_;
    return (int($E / $tilesize) == $x and int($N / $tilesize) == $y);
}

# is_point_in_shape SHAPE EASTING NORTHING
# SHAPE is a row from @shapes or whatever; EASTING and NORTHING are the
# coordinates of the point.
sub is_point_in_shape ($$$) {
    my ($S, $E, $N) = @_;
    
    # Bounding box.
    return 0 if ($S->minx() > $E or $S->maxx() < $E or $S->miny > $N or $S->maxy() < $N);

    my $res = 0;
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        $res += $sense if (mySociety::Polygon::is_point_in_poly($E, $N, length($vv) / (2 * doublesize()), $vv));
    }
    warn "area '", $S->name(), "' coords ($E, $N) result is $res" unless ($res == 0 || $res == 1);
unless ($res == 0 || $res == 1) {
    my $n = $S->name();
    $n =~ s/ /_/g;
    print STDERR "writing sense +1 areas to /tmp/$n=+1\n";
    print STDERR "writing sense -1 areas to /tmp/$n=-1\n";
    open(P, ">/tmp/$n=+1");
    open(N, ">/tmp/$n=-1");
print STDERR "  ... shape has ", scalar(@{$S->parts()}), " parts\n";
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        my @pp = unpack('d*', $vv);
print STDERR "  ... part sense $sense ", length($vv) / (2 * doublesize()), " vertices\n";
        for (my $i = 0; $i < @pp; $i += 2) {
            if ($sense > 0) {
                print P "$pp[$i] $pp[$i + 1]\n";
            } else {
                print N "$pp[$i] $pp[$i + 1]\n";
            }
        }
        if ($sense > 0) {
            print P "\n\n";
        } else {
            print N "\n\n";
        }
    }
    close(P);
    close(N);
}
    return 1 if ($res > 0);
}

# find_containing_areas EASTING NORTHING [HINTS]
# Return a list of all areas contain the point (EASTING, NORTHING). HINTS is an
# optional hash of area type to containing area; if specified, these areas will
# be tried first before an exhastive search for areas containing the point.
my ($total_shape_tests, $total_queries) = (0, 0);
sub find_containing_areas ($$;$) {
    my ($E, $N, $hints) = @_;
    $total_queries++;

    my %found;
    my %count = map { $_ => 0 } @interesting_areas;
    my %only;

    # Count number of areas of each type.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if ($S->deleted());
        ++$count{$S->area_type()};
        $only{$S->area_type()} = $S;
    }

    # Short-circuit interiors of certain areas. Each point must be in exactly
    # one WMC and EUR.
    foreach (qw(WMC EUR)) {
        if ($count{$_} == 1) {
            $found{$_} = $only{$_};
        }
    }

    # Consider types of local government at (roughly) county level. If we find
    # only one, then we can cheat a bit.
    my @locals = qw(LBO CTY UTA MTD);
    my $sum = 0;
    map { $sum += $count{$_} } @locals;
    if ($sum == 1) {
        # Only one type of contained local government region. We may be able to
        # short-circuit searches for contained regions.
        my ($lty) = grep { $count{$_} == 1 } @locals;
        $found{$lty} = $only{$lty};
        my %contents = (
                LBO => [qw(LBW LAC GLA)],
                CTY => [qw(CED DIS DIW)],
                UTA => [qw(UTE UTW)],
                MTD => [qw(MTW)]
            );
        foreach (@{$contents{$lty}}) {
            $found{$_} = $only{$_} if ($count{$_} == 1);
        }
    }

    # Try hinted points.
    if (defined($hints)) {
        foreach my $S (grep { defined($_) and !exists($found{$_->area_type()}) } values %$hints) {
            next if ($S->deleted());
            ++$total_shape_tests;
            $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
        }
    }

    # Devolved assemblies. These cover areas which correspond to Euro-areas.
    if (exists($found{EUR})) {
        if ($found{EUR}->devolved() eq 'L') {
            $found{LAC} = $only{LAC} if ($count{LAC} == 1);
            $found{GLA} = $only{GLA} if ($count{GLA} == 1);
        } elsif ($found{EUR}->devolved() eq 'S') {
            $found{SPC} = $only{SPC} if ($count{SPC} == 1);
            $found{SPE} = $only{SPE} if ($count{SPE} == 1);
        } elsif ($found{EUR}->devolved() eq 'W') {
            $found{WAC} = $only{WAC} if ($count{WAC} == 1);
            $found{WAE} = $only{WAE} if ($count{WAE} == 1);
        }
    }

    # Now the slow way.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if ($S->deleted());
        next if (exists($found{$S->area_type()}));  # only care about one shape of each type.
        ++$total_shape_tests;
        $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
    }

    return %found;
}

# Pass 2:
# Assign shapes to buckets. We do this by "approximate polygon rasterisation".
# Obviously the polygons from the shapefiles aren't convex, but we pretend that
# they are and put the shape in each bucket within a rough convex hull of the
# polygon's vertices. This must be done separately for each part, since shapes
# may have several disconnected convex parts (e.g. islands).
my @assigned_to_buckets;
sub assign_shapes_to_buckets () {
    my $n = 0;
    my $i = -1;
    foreach my $S (@shapes) {
        ++$i;
        ++$n;
        next if ($assigned_to_buckets[$i]);
        $assigned_to_buckets[$i] = 1;
        # Add the buckets in which vertices of the shape lie.
        foreach my $part (@{$S->parts()}) {
            my ($minx, $maxx);
            my @miny = ( );
            my @maxy = ( );
        
            # Don't rasterise holes.
            next if ($part->[0] == -1);
            my @vv = unpack('d*', $part->[1]);

            my ($ox, $oy);
            # NB: must close polygon
            for (my $i = 0; $i <= @vv; $i += 2) {
                my ($E, $N) = ($vv[$i % @vv], $vv[($i + 1) % @vv]);
                
                my ($x, $y) = (int($E / $tilesize), int($N / $tilesize));

                # Cope with the case where we've moved >1 tile horizontally.
                if (defined($ox) and $ox != $x and abs($ox - $x) > 1) {
                    my ($a, $b) = sort($ox, $x);
                    my ($A, $B) = sort($oy, $y);
                    for (my $i = $a; $i <= $b; ++$i) {
                        $miny[$i] = $A if (!defined($miny[$i]) || $A < $miny[$i]);
                        $maxy[$i] = $B if (!defined($maxy[$i]) || $B > $maxy[$i]);
                    }
                }

                $minx = $x if (!defined($minx) || $x < $minx);
                $maxx = $x if (!defined($maxx) || $x > $maxx);

                $miny[$x] = $y if (!defined($miny[$x]) || $y < $miny[$x]);
                $maxy[$x] = $y if (!defined($maxy[$x]) || $y > $maxy[$x]);
                
                $ox = $x;
                $oy = $y;
            }

            if (!defined($minx) || !defined($maxx)) {
                print STDERR "\r[2Kshape '", $S->name(), "' has no vertices\n";
                next;
            }

            # Fill the buckets between the shape bounds.
            my (@miny2, @maxy2);
            for (my $x = $minx; $x <= $maxx; ++$x) {
                die "no \$miny[$x]" unless (defined($miny[$x]));
                die "no \$maxy[$x]" unless (defined($maxy[$x]));
                $miny2[$x] = $miny[$x];
                $maxy2[$x] = $maxy[$x];
                for (my $X = $x - 1; $X <= $x + 1; ++$X) {
                    next if ($X < $minx || $X > $maxx);
                    $miny2[$x] = $miny[$X] if ($miny[$X] < $miny2[$x]);
                    $maxy2[$x] = $maxy[$X] if ($maxy[$X] > $maxy2[$x]);
                }
            }

            for (my $x = $minx; $x <= $maxx; ++$x) {
                for (my $y = $miny2[$x]; $y <= $maxy2[$x]; ++$y) {
                    push(@{$tiles->[$x]->[$y]}, $S);
                }
            }
        }
        STDERR->printf("\rfilling buckets: %d/%d shapes", $n, scalar(@shapes)) if (0 == ($n % 100));
    }
    STDERR->printf("\rfilling buckets: %d/%d shapes\n", $n, scalar(@shapes));
}

assign_shapes_to_buckets();

# Pass 3:
# Compute area parents for those which should have parents.
#
# There are several ways to do this. Firstly, where an area has an ONS code,
# the parent's ONS code will be a prefix of that code. So we can search for the
# area that way. Secondly, Boundary Line codes parent areas as collections of
# features which include the child areas. And thirdly we can search for the
# areas which contain a point within the child area, and pick out the result of
# the appropriate type.
print STDERR "finding parent areas... ";

$total_queries = 1 if ($total_queries == 0);
my $n = 0;
foreach my $S (@shapes) {
    ++$n;
    STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes; total p-in-p tests: %d; average tests/query = %f", $n, scalar(@shapes), $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));

    my $needparent = ($S->area_type() eq 'CPC' || exists($parentmap{$S->area_type()})) && !defined($S->parent());

    # Even areas which do not have a proper parent need to have a country.
    my $country = undef;

    # If this shape has a proper ONS code, use it to locate its parent and
    # country.
    my $parent = undef;
    my $ptype = $parentmap{$S->area_type()};
    if (defined($S->ons_code())) {
        if ($needparent) {
            my $newcode;
            if ($S->area_type() eq 'CPC') {
                # Parishes may be children of DIS, UTA, MTD, LBO (none at present), and their ONS codes
                # are three characters longer than their parents'.
                $newcode = substr($S->ons_code(), 0, length($S->ons_code()) - 3);
                $parent = $onscode_to_shape{$newcode};
                die "parish " . $S->name() . " #" . $S->ons_code() . " lacks a parent (should have ONS code #$newcode)"
                    unless (defined($parent));
            } else {
                $newcode = substr($S->ons_code(), 0, length($S->ons_code()) - 2);
                if (exists($onscode_to_shape{$newcode})) {
                    my $s = $onscode_to_shape{$newcode};
                    $parent = $s if ($s->area_type() eq $ptype);
                }
            }
        }

        # XXX I am assuming that ONS codes which begin '00N' are all in Wales,
        # and those which begin '00Q' or '00R' are all in Scotland. This is
        # true of SNAC 2003, and I assume will be in future too.
        # 00P is also Wales, and always has been
        if ($S->ons_code() =~ m#^00[NP]#) {
            $country = 'W';
        } elsif ($S->ons_code() =~ m#^00[QR]#) {
            $country = 'S';
        } else {
            $country = 'E';
        }
    }

    # Otherwise we know that certain types of shapes exist only in specific
    # countries.
    my %area_type_country = (
            CED => 'E',
            CTY => 'E',
            DIW => 'E',
            DIS => 'E',
            MTW => 'E',
            MTD => 'E',
            
            LBW => 'L',
            LBO => 'L',
            LAC => 'L',
            GLA => 'L',
            
            SPE => 'S',
            SPC => 'S',

            WAE => 'W',
            WAC => 'W'
        );

    $country = $area_type_country{$S->area_type()} if (!defined($country) and exists($area_type_country{$S->area_type()}));
    
    # Otherwise do it the slow way.
    if (!defined($country) or ($needparent && !defined($parent))) {
        my %areas = find_containing_areas($S->cx(), $S->cy());
        if ($needparent and !defined($parent)) {
            if (exists($areas{$ptype})) {
                $parent = $areas{$ptype};
            } else {
                warn $S->area_type() . " shape '", $S->name(), "' has no $ptype parent\n" unless (defined($parent));
            }
        }
        if (!defined($country)) {
            my $euro = $areas{EUR};
            if (!defined($euro)) {
                warn $S->area_type(), " shape '", $S->name(), "' is not in a Euro-area\n";
            } else {
                # Devolved assembly info.
                $country = $euro->devolved();
                $country = 'E' if ($country eq 'L');
            }
        }
    }

    # Record both parent and child.
    if ($needparent && defined($parent)) {
        $S->parent($parent);
        $parent->children($S);
    }
    $S->country($country) if (defined($country));
}
STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes\n", $n, scalar(@shapes));

#
# Now we need to:
#
# - identify which areas are new (i.e., the results of boundary changes etc.);
# 
# - construct new areas to incorporate boundary changes which are not yet
#   shown in the data; and
#
# Accordingly, process control file commands.
#

control_function(\@shapes, \%onscode_to_shape, \%area_type_to_shape);

# Having done this, we need to rasterise the new shapes.
assign_shapes_to_buckets();

#
# Last step: where an area corresponds to an area which was already in the
# data, identify the ID of the old area so that we can keep it for the new
# area.
#

# match_db_areas AREAS CONDITION
# AREAS is a list of areas, and CONDITION a where-clause fragment for selecting
# from the database a superset of areas which should match them. On success,
# annotates each of the AREAS with the appropriate ID; on failure, dies.
sub match_db_areas ($$) {
    my ($areas, $condition) = @_;

    my $g = current_generation($dbh);
    my $s = "select id, parent_area_id, unit_id, ons_code, type, name from area, area_name where area.id = area_name.area_id and name_type = 'O' and ($g >= generation_low and $g <= generation_high) and ($condition)";
    my $aa = $dbh->selectall_hashref($s, 'id');

    if (scalar(keys(%$aa)) < @$areas) {
        print STDERR "condition = $condition\ngot " . scalar(keys(%$aa)) . " from db, but have " . scalar(@$areas) . " to match\n";
        print STDERR "read in:\n";
        foreach (sort { $a->name() cmp $b->name() } @$areas) {
            print STDERR "    ", $_->name(), "\n";
        }
        print STDERR "in database:\n";
        foreach (sort { $a->{name} cmp $b->{name} } values %$aa) {
            print STDERR "    $_->{name}\n";
        }
        die "oops\n";
    }

    foreach my $A (@$areas) {
        my @i = sort { Text::LevenshteinXS::distance($A->name(), $a->{name}) <=> Text::LevenshteinXS::distance($A->name(), $b->{name}) } values(%$aa);
        die "closest match for '" . $A->name() . "', '" . $i[0]->{name} . "', is not similar enough"
            if (Text::LevenshteinXS::distance($A->name(), $i[0]->{name}) > length($A->name()) / 10);
        print STDERR $A->name(), " -> $i[0]->{name}\n";
        $A->id($i[0]->{id});
        delete($aa->{$A->id()});
    }
}

print STDERR "Finding existing database rows for areas...\n";

# For each area type, associate names.
foreach my $area_type (grep { !exists($parentmap{$_}) } @interesting_areas) {
    print STDERR "$area_type...\n";
    my @aa = grep { $_->alreadyexists() && !$_->deleted() } @{$area_type_to_shape{$area_type}};
    match_db_areas(\@aa, 'type = ' . $dbh->quote($area_type));
    
    # Now consider these shapes' children.
    if (exists($childmap{$area_type})) {
        foreach my $S (@aa) {
            print "--- children for ", $S->name(), "\n";
            my @children = grep { $_->alreadyexists() && !$_->deleted() } $S->children();
            match_db_areas(\@children, 'parent_area_id = ' . $S->id());
        }
    }
}

# Now write the areas into the database, either doing updates to generations
# and names where the areas already exist, or creating them anew where they do
# not.
$n = 0;
foreach my $S ((grep { !defined($_->parent()) } @shapes), (grep { defined($_->parent()) } @shapes)) {
    ++$n;
    next if ($S->deleted());
    my $id = $S->id();
    if (defined($id)) {
        # existing area
        $dbh->do("delete from area_name where area_id = ? and name_type = 'O'", {}, $id);
        $dbh->do("insert into area_name (area_id, name_type, name) values (?, 'O', ?)", {}, $id, $S->name());
        $dbh->do("update area set generation_high = ? where id = ?", {}, $generation, $id);
    } else {
        # new area
        $id = $dbh->selectrow_array("select nextval('area_id_seq')");
        $S->id($id);

        if ($S->ons_code()) {
            my $a = $dbh->selectrow_hashref('select * from area where ons_code = ?', {}, $S->ons_code());
            if (defined($a)) {
                my $n = $dbh->selectrow_array("select name from area_name where area_id = ? and name_type = 'O'", {}, $a->{id});
                die "was about to insert area '", $S->name(), "' with ONS Code ", $S->ons_code(), ", but an area #$a->{id} '$n' already exists\n";
            }
        }
 
        $dbh->do("insert into area (
                            id,
                            parent_area_id,
                            unit_id, ons_code,
                            type, country,
                            generation_low, generation_high
                        ) values (
                            ?,
                            ?,
                            ?, ?,
                            ?, ?,
                            ?, ?
                        )", {},
                            $id,
                            defined($S->parent()) ? $S->parent()->id() : undef,
                            $S->aaid(), $S->ons_code(),
                            $S->area_type(), $S->country(),
                            $generation, $generation);

        $dbh->do("insert into area_name (area_id, name_type, name) values (?, 'O', ?)", {}, $S->id(), $S->name());
    }
    printf STDERR "\rUpdating database: %d/%d shapes", $n, scalar(@shapes) if (($n % 100) == 0);
}
printf STDERR "\rUpdating database: %d/%d shapes\n", $n, scalar(@shapes);
$dbh->commit();

# Reset statistics.
$total_shape_tests = $total_queries = 0;

# Read list of postcodes and coordinates, do point-in-polygon tests for each
# one.
{
    my $n = 0;
    my $starttime = time();

    # Cache area result between postcode tests for speed.
    my %areas = map { $_ => undef } @interesting_areas;

    while (defined(my $line = <STDIN>)) {
        chomp $line;
        $line =~ s/\r//g; # In case it's using DOS line endings
        my @x = split(/,/, $line);
        
        my ($pc, $qual, $E, $N) = ($x[0], $x[5], $x[6], $x[7]);
        $pc =~ s/[" ]//g;

        %areas = find_containing_areas($E, $N, \%areas);
        if (exists(&control_function_postcode)) {
            control_function_postcode($pc, \%areas, \%area_type_to_shape);
        }

        # Sanity checks.
        foreach my $musthave (qw(WMC EUR)) {
            warn "no $musthave for $pc ($E, $N)\n" unless (defined($areas{$musthave}));
        }

        foreach my $bothneither ([qw(DIS DIW)], [qw(CTY CED)], [qw(GLA LAC)], [qw(LBO LBW)], [qw(MTD MTW)], [qw(SPE SPC)], [qw(WAE WAC)], [qw(DIS CTY)]) {
            # Locations in the Scilly Isles have a county ("Isles of Scilly")
            # but no CEDs.
            next if ($bothneither->[0] eq 'CTY' and $pc =~ m#^TR2#);
        
            warn "$bothneither->[0] but no $bothneither->[1] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[0]}) and !defined($areas{$bothneither->[1]}));
            warn "$bothneither->[1] but no $bothneither->[0] for $pc ($E, $N)\n" if (defined($areas{$bothneither->[1]}) and !defined($areas{$bothneither->[0]}));
        }

        foreach my $oneof ([qw(LBO UTA DIS MTD)], [qw(LAC SPC WAC)], [qw(CTY UTA MTA)]) {
            my @a = grep { defined($areas{$_}) } @$oneof;
            warn join(" ", @a) . " for $pc ($E, $N)\n" if (@a > 1);
        }
       
        my $pcid = get_postcode_id($dbh, $pc, $E, $N);
        $dbh->do('delete from postcode_area where postcode_id = ?', {}, $pcid);
        foreach my $S (grep { defined($_) } values %areas) {
            next if ($S->deleted());
            $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $S->id());
        }

        ++$n;
        if (0 == ($n % 100)) {
            # Put this commit in to see what is happening while it runs, but lose rollback if it goes wrong            
            $dbh->commit();
            STDERR->printf("\r%d postcodes (%s); total p-in-p tests: %d; average tests/query = %f, time/query = %f", $n, $pc, $total_shape_tests, $total_shape_tests / $total_queries, (time()-$starttime) / $n) if (0 == ($n % 100));
        }
    }
    STDERR->printf("\r[2K%d postcodes\n", $n);
}

# print STDERR "dbh->commit disabled, rolling back\n";
$dbh->commit();

