#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# add_boundaryline_geodata:
# Add geographical information about boundaries to MaPit, from BoundaryLine NTF/ShapeFile files.
#
# Specify directories containing BoundaryLine NTF/ShapeFile files as the parameters. Existing
# data in area_geometry for each area found in the NTF/ShapeFile files is replaced.
#

my $rcsid = ''; $rcsid .= '$Id: add_boundaryline_geodata,v 1.11 2009-12-21 17:34:01 matthew Exp $';

use strict;

use DBI;
use DBD::Pg;
use Fcntl;
use Geo::OSBoundaryLine;
use IO::Handle;
use Data::Dumper;
use mySociety::GeoUtil;
use mySociety::Polygon;
use File::Find;

use Common;
use Area;
use BoundaryLine qw(doublesize);

die "arguments are directories containing boundaryline NTF/ShapeFile files" unless @ARGV;

# @shapes
# List of Area objects for each area we're interested in.
my @shapes;
my %onscode_to_shape;
my %area_type_to_shape;
# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;

# Open database.
my $dbh = Common::connect_to_mapit_database();

# Get list of all areas, indexed by OS name
my $g = current_generation($dbh);
# my @as = (2428,2402,2381,2341,2393,2429,2472,2399,2470,2414,2608,2398,2396,2385,2383,2392,2345); # XXX Was needed for something at one point, with $g manually set to 6?
my $s = "select id, parent_area_id, unit_id, ons_code, type, name from area, area_name where area.id = area_name.area_id and name_type = 'O' and ($g >= generation_low and $g <= generation_high)";
$s = $dbh->selectall_arrayref($s, { Slice => {} });
my %os_name_to_db_info;
foreach (@$s) {
    push @{$os_name_to_db_info{$_->{name}}{$_->{type}}}, $_->{id};
    $os_name_to_db_info{$_->{name}}{$_->{ons_code}} = $_->{id} if $_->{ons_code};
    push @{$os_name_to_db_info{$_->{name}}{id}}, $_->{id};
}

# Recursively scan for NTF files and load them all in
find(\&wanted, @ARGV);
sub wanted {
    if (/\.ntf$/i) {
        BoundaryLine::load_ntf_file($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
    } elsif (/\.shp$/) {
        BoundaryLine::load_shapefile($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
    }
}

# Loop through shapes
my %manually_done;
foreach my $A (@shapes) {
    print STDERR $A->name() . " " . $A->area_type() . "\n";

    my ($min_lat, $min_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->minx(), $A->miny(), 'G');
    my ($max_lat, $max_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->maxx(), $A->maxy(), 'G');
    my $centre_e = ($A->minx() + $A->maxx()) / 2;
    my $centre_n = ($A->miny() + $A->maxy()) / 2;
    my ($centre_lat, $centre_lon) = mySociety::GeoUtil::national_grid_to_wgs84($centre_e, $centre_n, 'G');

    my $db_id;
    if ($A->ons_code()) {
        $db_id = $os_name_to_db_info{$A->name()}{$A->ons_code()};
    }
    if (!$db_id) {
        $db_id = dedupe($os_name_to_db_info{$A->name()}{$A->area_type()});
    }
    if (!$db_id) {
        $db_id = dedupe($os_name_to_db_info{$A->name()}{id});
    }
    if (!$db_id) {
        print "couldn't find exact name match ". $A->name() . " in database\n";
        next;
    }

    my $binary_poly; # format as documented in mapit-schema.sql
    my $parts_count = scalar(@{$A->parts()});
    my $calculated_surface_area;
    foreach (@{$A->parts()}) {
        my ($sense, $vv) = @$_;
        my $vertices_count = length($vv) / (2 * doublesize());
        # print STDERR "  ... part $sense sense $vertices_count vertices\n";
        $binary_poly .= pack('i', $sense);
        $binary_poly .= pack('i', $vertices_count);
        $binary_poly .= $vv;
        
        # Calculate area from the polygon 
        my $surface_area = abs(mySociety::Polygon::poly_area($vertices_count, $vv));
        if ($sense > 0) {  
            $calculated_surface_area += $surface_area;
        } elsif ($sense < 0) {
            $calculated_surface_area -= $surface_area;
        } else {
            die "zero sense value for part in " . $A->name();
        }
    }
    die "Calculated surface zero or negative ($calculated_surface_area) for " . $A->name() if ($calculated_surface_area <= 0);
    my $non_inland_area = $A->non_inland_area();
    my $hectares = $A->hectares();
    my $area_discrepency = abs(($calculated_surface_area - ($hectares * 10000)));

    print STDERR "\tDB identifier: " . $db_id . "\n";
    print STDERR "\tBounds: " . $A->minx() . "E " . $A->miny() . "N";
    print STDERR " " . $A->maxx() . "E " . $A->maxy() . "N\n";
    print STDERR "\tBounds lat/lon: $min_lat $min_lon --> $max_lat $max_lon\n";
    print STDERR "\tCentre: $centre_e E $centre_n N ";
    print STDERR " lat/lon: $centre_lat $centre_lon\n";
    print STDERR "\tcalc area $calculated_surface_area m2, ntf area $hectares ha, non inland area $non_inland_area ha\n";
    print STDERR "\tdiscrepency " . $area_discrepency . " ratio " . ($area_discrepency / $calculated_surface_area) . "\n";
    print STDERR "\tgnuplot $area_discrepency $non_inland_area\n";

    die "calculated $calculated_surface_area and hectares $hectares areas disagree by lots" if $area_discrepency > 1000;

    $dbh->do("delete from area_geometry where area_id = ?", {}, $db_id);

    $dbh->do("insert into area_geometry (
            area_id,
            centre_e, centre_n,
            min_e, min_n,
            max_e, max_n,
            area, parts
        ) values (
            ?,
            ?, ?,
            ?, ?,
            ?, ?,
            ?, ?
        ) ", {}, 
            $db_id,
            $centre_e, $centre_n,
            $A->minx(), $A->miny(),
            $A->maxx(), $A->maxy(),
            $hectares * 10000, $parts_count
        );
    #area 

    # Horrid. To insert a value into a BYTEA column we need to do a little
    # parameter-binding dance:
    my $s = $dbh->prepare(q#update area_geometry set polygon = ? where area_id = ?#);
    $s->bind_param(1, $binary_poly, { pg_type => DBD::Pg::PG_BYTEA });
    $s->bind_param(2, $db_id);
    $s->execute();
}

$dbh->commit();


sub dedupe {
    my $db_ids = shift;
    $db_ids = [] unless $db_ids;
    @$db_ids = grep { !$manually_done{$_} } @$db_ids;
    return undef unless @$db_ids;
    return $db_ids->[0] if @$db_ids == 1;

    my $ids = join(',', @$db_ids);
    my $s = $dbh->selectall_arrayref("select id, parent_area_id,name from area,area_name where parent_area_id=area_id and name_type='F' and id in ($ids)", { Slice => {} });
    print map { "* $_->{id} $_->{name}\n" } @$s;
    print "Choices for " . $A->name() . ', ' . $A->area_type()
        . ', file ' . $A->filename() . ' are ' . $ids . ' ? ';
    $db_id = <>;
    chomp($db_id);
    $manually_done{$db_id} = 1;
    return $db_id;
}
