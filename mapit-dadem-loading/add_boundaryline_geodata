#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# add_boundaryline_geodata:
# Add geographical information about boundaries to MaPit, from BoundaryLine NTF files.
#
# Specify a directory containing BoundaryLine NTF files as the only parameter. Existing
# data in area_geometry for each area found in the NTF files is replaced.
#

my $rcsid = ''; $rcsid .= '$Id: add_boundaryline_geodata,v 1.7 2006-09-28 10:06:42 francis Exp $';

use strict;

use DBI;
use DBD::Pg;
use Fcntl;
use Geo::OSBoundaryLine;
use IO::Handle;
use Data::Dumper;
use mySociety::GeoUtil;
use mySociety::Polygon;
use File::Find;

use Common;
use Area;
use BoundaryLine qw(%interesting_areas @interesting_areas %childmap %parentmap doublesize poly_area);

my $boundaryline_directory = shift(@ARGV);
die "argument is directory containing boundaryline NTF files" unless $boundaryline_directory;

# @shapes
# List of Area objects for each area we're interested in.
my @shapes;
my %onscode_to_shape;
my %area_type_to_shape;
# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;

# Open database.
my $dbh = Common::connect_to_mapit_database();

# Get list of all areas, indexed by OS name
my $g = current_generation($dbh);
my $s = "select id, parent_area_id, unit_id, ons_code, type, name from area, area_name where area.id = area_name.area_id and name_type = 'O' and ($g >= generation_low and $g <= generation_high)";
my $os_name_to_db_info = $dbh->selectall_hashref($s, 'name');

# Recursively scan for NTF files and load them all in
find(\&wanted, $boundaryline_directory);
sub wanted {
    BoundaryLine::load_ntf_file($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
}

# Loop through shapes
foreach my $A (@shapes) {
    print STDERR $A->name() . " " . $A->area_type() . "\n";

    my ($min_lat, $min_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->minx(), $A->miny(), 'G');
    my ($max_lat, $max_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->maxx(), $A->maxy(), 'G');
    my $centre_e = ($A->minx() + $A->maxx()) / 2;
    my $centre_n = ($A->miny() + $A->maxy()) / 2;
    my ($centre_lat, $centre_lon) = mySociety::GeoUtil::national_grid_to_wgs84($centre_e, $centre_n, 'G');

    my $db_entry = $os_name_to_db_info->{$A->name()}; 
    if (!$db_entry) {
        warn "couldn't find exact name match ". $A->name() . " in database";
        next;
    }

    my $binary_poly; # format as documented in mapit-schema.sql
    my $parts_count = scalar(@{$A->parts()});
    my $calculated_surface_area;
    foreach (@{$A->parts()}) {
        my ($sense, $vv) = @$_;
        my $vertices_count = length($vv) / (2 * doublesize());
        # print STDERR "  ... part $sense sense $vertices_count vertices\n";
        $binary_poly .= pack('i', $sense);
        $binary_poly .= pack('i', $vertices_count);
        $binary_poly .= $vv;
        
        # Calculate area from the polygon 
        my $surface_area = abs(mySociety::Polygon::poly_area($vertices_count, $vv));
        if ($sense > 0) {  
            $calculated_surface_area += $surface_area;
        } elsif ($sense < 0) {
            $calculated_surface_area -= $surface_area;
        } else {
            die "zero sense value for part in " . $A->name();
        }
    }
    die "Calculated surface zero or negative ($calculated_surface_area) for " . $A->name() if ($calculated_surface_area <= 0);
    my $non_inland_area = $A->non_inland_area();
    my $hectares = $A->hectares();
    my $area_discrepency = abs(($calculated_surface_area - ($hectares * 10000)));

    print STDERR "\tDB identifier: " . $db_entry->{id} . "\n";
    print STDERR "\tBounds: " . $A->minx() . "E " . $A->miny() . "N";
    print STDERR " " . $A->maxx() . "E " . $A->maxy() . "N\n";
    print STDERR "\tBounds lat/lon: $min_lat $min_lon --> $max_lat $max_lon\n";
    print STDERR "\tCentre: $centre_e E $centre_n N ";
    print STDERR " lat/lon: $centre_lat $centre_lon\n";
    print STDERR "\tcalc area $calculated_surface_area m2, ntf area $hectares ha, non inland area $non_inland_area ha\n";
    print STDERR "\tdiscrepency " . $area_discrepency . " ratio " . ($area_discrepency / $calculated_surface_area) . "\n";
    print STDERR "\tgnuplot $area_discrepency $non_inland_area\n";

    die "calculated $calculated_surface_area and hectares $hectares areas disagree by lots" if $area_discrepency > 1000;

    $dbh->do("delete from area_geometry where area_id = ?", {}, $db_entry->{id});

    $dbh->do("insert into area_geometry (
            area_id,
            centre_e, centre_n,
            min_e, min_n,
            max_e, max_n,
            area, parts
        ) values (
            ?,
            ?, ?,
            ?, ?,
            ?, ?,
            ?, ?
        ) ", {}, 
            $db_entry->{id},
            $centre_e, $centre_n,
            $A->minx(), $A->miny(),
            $A->maxx(), $A->maxy(),
            $hectares * 10000, $parts_count
        );
    #area 

    # Horrid. To insert a value into a BYTEA column we need to do a little
    # parameter-binding dance:
    my $s = $dbh->prepare(q#update area_geometry set polygon = ? where area_id = ?#);
    $s->bind_param(1, $binary_poly, { pg_type => DBD::Pg::PG_BYTEA });
    $s->bind_param(2, $db_entry->{id});
    $s->execute();
}

$dbh->commit();


