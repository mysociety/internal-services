#!/usr/bin/perl -w
#
# process_goveval_data:
# Import GovEval dump files of councillors.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_goveval_data,v 1.1 2004-11-09 08:28:28 francis Exp $';

use strict;

use DBI;
use DBD::SQLite;
use Text::CSV;

my $dbh = DBI->connect('dbi:SQLite:dbname=mapit.sqlite', '', '', { AutoCommit => 0, RaiseError => 1 });

#my %name_to_id;

my $s = $dbh->prepare('select distinct area.id, area.type, area.name, parent_area.id, parent_area.type, parent_area.name from area, area as parent_area where parent_area.id = area.parent_area_id');

$s->execute();

my %all_areas;
my %parent_areas;
my %child_areas;
my %id_to_name;
my %id_to_type;
my %parent_id_to_name;

my %parent_index;
my %child_index;

sub do_index ($$$) {
    my ($index, $name, $id) = @_;
    foreach (map { lc($_) } split(/[^A-Za-z]+/, $name)) {
        $index->{$_}->{$id} = 1;
    }
}

sub find_matches ($$;$) {
    my ($index, $query, $candidates) = @_;

    # ad-hoc fixes
    $query =~ s#W\. Isles#Na H-Eileanan an Iar#;    # Scots Gaelic(?) name for Western Isles
    $query =~ s#Renfrewsh'r#Renfrewshire#g;
    $query =~ s#N\.#$1 North Northern #g;
    $query =~ s#E\.#$1 East Eastern #g;
    $query =~ s#S\.#$1 South Southern #g;
    $query =~ s#W\.#$1 West Western #g;
    $query =~ s#Corp #City and County #;    # cope with "Corp of London"

    die if (!defined($query));

    my %matches;

    my $allowed_types;
    my $threshold = 0;
    if (!defined($candidates)) {
        if ($query =~ m#\(([A-Z]{2})\)#) {
            my %amap = (
                    BC => [qw(LBO DIS UTA MTD)],
                    UC => [qw(UTA)],
                    DC => [qw(DIS MTD UTA)]
                );
            $allowed_types = { map { $_ => 1 } @{$amap{$1}} };
        } elsif ($query =~ m#County Council#) {
            $allowed_types = { CTY => 1 };
        } elsif ($query =~ m#(City Council|City of )#) {
            $allowed_types = { DIS => 1, MTD => 1, UTA => 1 };
        }
        $candidates = \%parent_id_to_name;
        $threshold = 0.025;
    } else {
        $allowed_types = { map { $_ => 1 } qw(DIW CED UTW UTE MTW LBW) };
    }
    
    $query =~ s# of # #g;

    foreach my $word (map { lc($_) } split(/[^A-Za-z]+/, $query)) {
        next if (!exists($index->{$word}));
        foreach my $id (keys %{$index->{$word}}) {
            next if (defined($allowed_types) and !exists($allowed_types->{$id_to_type{$id}}));
            $matches{$id} += 1 / scalar(keys %{$index->{$word}});
        }
    }

    # prefer short to long matches where possible...
    foreach (keys %matches) {
        $matches{$_} /= sqrt(length($id_to_name{$_}));
    }

    # require same compass points in match as in query
    foreach my $id (keys %matches) {
        foreach my $dir (qw(north east south west)) {
            my $m = 0;
            ++$m if ($id_to_name{$id} =~ m#\b$dir\b#i);
            ++$m if ($query =~ m#\b$dir\b#i);
            delete $matches{$id} if ($m == 1);
        }
    }

    return sort { $matches{$b} <=> $matches{$a} } grep { exists($candidates->{$_}) and $matches{$_} > $threshold } keys %matches;
}

while (my ($id, $type, $name, $parent_id, $parent_type, $parent_name) = $s->fetchrow_array()) {
    $id_to_name{$id} = $name;
    $id_to_type{$id} = $type;
    $id_to_type{$parent_id} = $parent_type;
    $id_to_name{$parent_id} = $parent_name;
    my $nn = join("\0", $name, $parent_name);
    if (exists($all_areas{$nn})) {
        warn "duplicate $name in $parent_name\n";
    }
    $all_areas{$nn} = $id;

    if (exists($parent_areas{$parent_name}) and $parent_areas{$parent_name} ne $parent_id) {
        warn "duplicate parent area $parent_name\n";
    }

    if (!exists($parent_areas{$parent_name})) {
        do_index(\%parent_index, $parent_name, $parent_id);
    }

    $parent_areas{$parent_name} = $parent_id;

    if (!exists($child_areas{$parent_id}->{$id})) {
        $child_index{$parent_id} ||= {};
        do_index($child_index{$parent_id}, $name, $id);
        $child_areas{$parent_id}->{$id} = 1;
    }
}

%parent_id_to_name = reverse(%parent_areas);

# We can't handle Northern Ireland yet, so just ignore it (in the same way
# that countless Prime Ministers wished they could).
my %northern_irish_councils = map { $_ => 1 } (
        "Derry City Council",
        "Antrim (BC)",
        "Ards (BC)",
        "Armagh (DC)",
        "Ballymena (BC)",
        "Ballymoney (BC)",
        "Banbridge (DC)",
        "Belfast City Council",
        "Carrickfergus (BC)",
        "Castlereagh (BC)",
        "Coleraine (BC)",
        "Cookstown (DC)",
        "Craigavon (BC)",
        "Down (DC)",
        "Dungannon (DC)",
        "Fermanagh (DC)",
        "Larne (BC)",
        "Limavady (BC)",
        "Lisburn (BC)",
        "Magherafelt (DC)",
        "Moyle (DC)",
        "N. Down (BC)",
        "Newry & Mourne (DC)",
        "Newtownabbey (BC)",
        "Omagh (DC)",
        "Strabane (DC)",
    );

# Parse the GovEval data.
my $C = new Text::CSV;

<STDIN>;    # header line

my @data = ( );

while (my $line = <STDIN>) {
    chomp($line);
    $C->parse($line);
    my ($first, $last, $vdiv, $council, $email) = $C->fields();
    next if ($northern_irish_councils{$council});
    push(@data, [$C->fields()]);
}

my %gename_to_id;
my %id_to_gename;
my %bad;

# Obtain mapping from GovEval's council names to our area IDs.
foreach (@data) {
    my ($first, $last, $vdiv, $council, $email) = @$_;

    next if (exists($gename_to_id{$council})); # seen this already
    next if (exists($bad{$council}));

    my @matches = find_matches(\%parent_index, $council);

    if (!@matches) {
        warn "no matching names for $council\n";
        $bad{$council} = 1;
    } else {
        if (exists($id_to_gename{$matches[0]})) {
            warn "council $id_to_name{$matches[0]} ($matches[0]) already mapped to $id_to_gename{$matches[0]}, also matches $council\n";
        } else {
            $gename_to_id{$council} = $matches[0];
            $id_to_gename{$matches[0]} = $council;
        }
    }
}

#print join("\n", map { "$_ = $id_to_name{$gename_to_id{$_}}" } sort keys %gename_to_id ), "\n";

unlink('dadem-new.sqlite') or die "dadem-new.sqlite: $!" if (-e 'dadem-new.sqlite');
my $d_dbh = DBI->connect('dbi:SQLite:dbname=dadem-new.sqlite', '', '', { AutoCommit => 0, RaiseError => 1 });
$d_dbh->do(q#
create table representative (
    id integer not null primary key,
    area_id integer not null,
    area_type char(3) not null,
    name text not null,
    party text not null,
    method integer not null,    -- 0: either, 1: fax, 2: email
    email text,
    fax text
);#);

# Now obtain a mapping from GovEval's ward/ED names to our area IDs.
foreach (@data) {
    my ($first, $last, $vdiv, $council, $email) = @$_;

    next unless (exists($gename_to_id{$council}));
    next if (exists($bad{$council}));

    my $comp = "$council\0$vdiv";

    # Special case for elected mayors.
    $gename_to_id{$comp} = $gename_to_id{$council} if ($vdiv eq 'Elected Mayor');

    next if (exists($bad{$comp}));
    
    if (!exists($gename_to_id{$comp})) {
        my @matches = find_matches($child_index{$gename_to_id{$council}}, $vdiv, $child_areas{$gename_to_id{$council}});

        if (@matches) {
            $gename_to_id{$comp} = $matches[0];
        } else {
            print STDERR "$council / $vdiv: no matches found; could be:\n";
            foreach (sort { $id_to_name{$a} cmp $id_to_name{$b} } keys %{$child_areas{$gename_to_id{$council}}}) {
                print STDERR "    $id_to_name{$_} ($_)\n";
            }
            $bad{$comp} = 1;
        }
    }

    if (exists($gename_to_id{$comp})) {
        $d_dbh->do("insert into representative (area_id, area_type, name, party, method, email, fax) values (?, ?, ?, '', ?, ?, ?)", {},
                    $gename_to_id{$comp},
                    $id_to_type{$gename_to_id{$comp}},
                    "$first $last",
                    2,
                    $email,
                    undef);
    }
}
$d_dbh->commit();

$dbh->disconnect();
$d_dbh->disconnect();
