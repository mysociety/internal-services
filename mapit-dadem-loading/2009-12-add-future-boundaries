#!/usr/bin/perl -w -I../perllib -I ../../perllib
#
# add-future-boundaries
# Load the future Westminster constituencies, and compare postcodes
# against their areas, to form a new bit of the database used by MaPit.
#
# The strategy here is broadly the same as process_boundary_line. Other things
# need to be run after to deal with mistakes.
#
# The arguments should be the ShapeFiles from Boundary-Line with future boundaries in
# them *plus* Euro regions so we can do country match-up. Feed postcodes in on a pipe.
#
# You'll need to call create_new_generation first to make the new generation in
# the db.
#
# Copyright (c) 2009 UK Citizens Online Democracy. All rights reserved.
# Email: matthew@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: 2009-12-add-future-boundaries,v 1.1 2009-12-23 11:09:43 matthew Exp $';

use strict;
require 5.8.0;

use DBD::Pg;
use Common;
use BoundaryLine qw(doublesize);
use mySociety::Polygon;
use mySociety::GeoUtil;

# @shapes
# List of Area objects for each area we're interested in.
my @shapes;
my %onscode_to_shape;
my %area_type_to_shape;
# We may have several shapes in files with the same administrative area ID. We
# amalgamate them before writing them to the database.
my %aaid_to_shape;

my $dbh = Common::connect_to_mapit_database();
my $generation = $dbh->selectrow_array('select id from new_generation');
die "no new generation available" if (!defined($generation));

die "arguments are ShapeFile files" unless @ARGV > 0;
foreach (@ARGV) {
    print STDERR "\r$_\n";
    BoundaryLine::load_shapefile($_, \@shapes, \%onscode_to_shape, \%area_type_to_shape, \%aaid_to_shape);
}

STDERR->printf("\rreading shapes: %d total\n", scalar(@shapes));

# Stick the shapes into buckets for a set of grid squares.
my $tilesize = 1000;   # 1km buckets
my $tiles = [ ];

# is_point_in_shape SHAPE EASTING NORTHING
# SHAPE is a row from @shapes or whatever; EASTING and NORTHING are the
# coordinates of the point.
sub is_point_in_shape ($$$) {
    my ($S, $E, $N) = @_;
    
    # Bounding box.
    return 0 if ($S->minx() > $E or $S->maxx() < $E or $S->miny > $N or $S->maxy() < $N);

    my $res = 0;
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        $res += $sense if (mySociety::Polygon::is_point_in_poly($E, $N, length($vv) / (2 * doublesize()), $vv));
    }
    warn "area '", $S->name(), "' coords ($E, $N) result is $res" unless ($res == 0 || $res == 1);
unless ($res == 0 || $res == 1) {
    my $n = $S->name();
    $n =~ s/ /_/g;
    print STDERR "writing sense +1 areas to /tmp/$n=+1\n";
    print STDERR "writing sense -1 areas to /tmp/$n=-1\n";
    open(P, ">/tmp/$n=+1");
    open(N, ">/tmp/$n=-1");
print STDERR "  ... shape has ", scalar(@{$S->parts()}), " parts\n";
    foreach (@{$S->parts()}) {
        my ($sense, $vv) = @$_;
        my @pp = unpack('d*', $vv);
print STDERR "  ... part sense $sense ", length($vv) / (2 * doublesize()), " vertices\n";
        for (my $i = 0; $i < @pp; $i += 2) {
            if ($sense > 0) {
                print P "$pp[$i] $pp[$i + 1]\n";
            } else {
                print N "$pp[$i] $pp[$i + 1]\n";
            }
        }
        if ($sense > 0) {
            print P "\n\n";
        } else {
            print N "\n\n";
        }
    }
    close(P);
    close(N);
}
    return 1 if ($res > 0);
}

# find_containing_areas EASTING NORTHING [HINTS]
# Return a list of all areas contain the point (EASTING, NORTHING). HINTS is an
# optional hash of area type to containing area; if specified, these areas will
# be tried first before an exhastive search for areas containing the point.
my ($total_shape_tests, $total_queries) = (0, 0);
sub find_containing_areas ($$;$) {
    my ($E, $N, $hints) = @_;
    $total_queries++;

    my %found;
    my %count = ( WMC => 0, EUR => 0 );
    my %only;

    # Count number of areas of each type.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        ++$count{$S->area_type()};
        $only{$S->area_type()} = $S;
    }

    # Short-circuit interiors of certain areas. Each point must be in exactly
    # one WMC and EUR.
    foreach (qw(WMC EUR)) {
        if ($count{$_} == 1) {
            $found{$_} = $only{$_};
        }
    }

    # Try hinted points.
    if (defined($hints)) {
        foreach my $S (grep { defined($_) and !exists($found{$_->area_type()}) } values %$hints) {
            ++$total_shape_tests;
            $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
        }
    }

    # Now the slow way.
    foreach my $S (@{$tiles->[int($E / $tilesize)]->[int($N / $tilesize)]}) {
        next if (exists($found{$S->area_type()}));  # only care about one shape of each type.
        ++$total_shape_tests;
        $found{$S->area_type()} = $S if (is_point_in_shape($S, $E, $N));
    }

    return %found;
}

# Pass 2:
# Assign shapes to buckets. We do this by "approximate polygon rasterisation".
# Obviously the polygons from the shapefiles aren't convex, but we pretend that
# they are and put the shape in each bucket within a rough convex hull of the
# polygon's vertices. This must be done separately for each part, since shapes
# may have several disconnected convex parts (e.g. islands).
my @assigned_to_buckets;
sub assign_shapes_to_buckets () {
    my $n = 0;
    my $i = -1;
    foreach my $S (@shapes) {
        ++$i;
        ++$n;
        next if ($assigned_to_buckets[$i]);
        $assigned_to_buckets[$i] = 1;
        # Add the buckets in which vertices of the shape lie.
        foreach my $part (@{$S->parts()}) {
            my ($minx, $maxx);
            my @miny = ( );
            my @maxy = ( );
        
            # Don't rasterise holes.
            next if ($part->[0] == -1);
            my @vv = unpack('d*', $part->[1]);

            my ($ox, $oy);
            # NB: must close polygon
            for (my $i = 0; $i <= @vv; $i += 2) {
                my ($E, $N) = ($vv[$i % @vv], $vv[($i + 1) % @vv]);
                
                my ($x, $y) = (int($E / $tilesize), int($N / $tilesize));

                # Cope with the case where we've moved >1 tile horizontally.
                if (defined($ox) and $ox != $x and abs($ox - $x) > 1) {
                    my ($a, $b) = sort($ox, $x);
                    my ($A, $B) = sort($oy, $y);
                    for (my $i = $a; $i <= $b; ++$i) {
                        $miny[$i] = $A if (!defined($miny[$i]) || $A < $miny[$i]);
                        $maxy[$i] = $B if (!defined($maxy[$i]) || $B > $maxy[$i]);
                    }
                }

                $minx = $x if (!defined($minx) || $x < $minx);
                $maxx = $x if (!defined($maxx) || $x > $maxx);

                $miny[$x] = $y if (!defined($miny[$x]) || $y < $miny[$x]);
                $maxy[$x] = $y if (!defined($maxy[$x]) || $y > $maxy[$x]);
                
                $ox = $x;
                $oy = $y;
            }

            if (!defined($minx) || !defined($maxx)) {
                print STDERR "\r[2Kshape '", $S->name(), "' has no vertices\n";
                next;
            }

            # Fill the buckets between the shape bounds.
            my (@miny2, @maxy2);
            for (my $x = $minx; $x <= $maxx; ++$x) {
                die "no \$miny[$x]" unless (defined($miny[$x]));
                die "no \$maxy[$x]" unless (defined($maxy[$x]));
                $miny2[$x] = $miny[$x];
                $maxy2[$x] = $maxy[$x];
                for (my $X = $x - 1; $X <= $x + 1; ++$X) {
                    next if ($X < $minx || $X > $maxx);
                    $miny2[$x] = $miny[$X] if ($miny[$X] < $miny2[$x]);
                    $maxy2[$x] = $maxy[$X] if ($maxy[$X] > $maxy2[$x]);
                }
            }

            for (my $x = $minx; $x <= $maxx; ++$x) {
                for (my $y = $miny2[$x]; $y <= $maxy2[$x]; ++$y) {
                    push(@{$tiles->[$x]->[$y]}, $S);
                }
            }
        }
        STDERR->printf("\rfilling buckets: %d/%d shapes", $n, scalar(@shapes)) if (0 == ($n % 100));
    }
    STDERR->printf("\rfilling buckets: %d/%d shapes\n", $n, scalar(@shapes));
}

assign_shapes_to_buckets();

# Pass 3:
# Compute area parents for those which should have parents.
#
# There are several ways to do this. Firstly, where an area has an ONS code,
# the parent's ONS code will be a prefix of that code. So we can search for the
# area that way. Secondly, Boundary Line codes parent areas as collections of
# features which include the child areas. And thirdly we can search for the
# areas which contain a point within the child area, and pick out the result of
# the appropriate type.
print STDERR "finding parent areas... ";

$total_queries = 1 if ($total_queries == 0);
my $n = 0;
foreach my $S (@shapes) {
    ++$n;
    STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes; total p-in-p tests: %d; average tests/query = %f", $n, scalar(@shapes), $total_shape_tests, $total_shape_tests / $total_queries) if (0 == ($n % 100));

    my $country = undef;
    my %areas = find_containing_areas($S->cx(), $S->cy());
    my $euro = $areas{EUR};
    if (!defined($euro)) {
        die $S->area_type(), " shape '", $S->name(), "' is not in a Euro-area\n";
    } else {
        # Devolved assembly info.
        $country = $euro->devolved();
        $country = 'E' if ($country eq 'L');
    }
    $S->country($country) if (defined($country));
}
STDERR->printf("\r[2Kfinding parent areas: %d/%d shapes\n", $n, scalar(@shapes));

# Having done this, we need to rasterise the new shapes.
assign_shapes_to_buckets();

# Now write the areas into the database, either doing updates to generations
# and names where the areas already exist, or creating them anew where they do
# not.
$n = 0;
foreach my $S (@shapes) {
    my $id = $dbh->selectrow_array("select nextval('area_id_seq')");
    $S->id($id);

    $dbh->do("insert into area (
                    id, parent_area_id,
                    unit_id, ons_code,
                    type, country,
                    generation_low, generation_high
                ) values (
                    ?, ?,
                    ?, ?,
                    ?, ?,
                    ?, ?
                )", {},
                    $id, undef,
                    $S->aaid(), $S->ons_code(),
                    $S->area_type(), $S->country(),
                    $generation, $generation);

    $dbh->do("insert into area_name (area_id, name_type, name) values (?, 'O', ?)", {}, $S->id(), $S->name());
    add_geometry($S);
    ++$n;
    printf STDERR "\rUpdating database: %d/%d shapes", $n, scalar(@shapes) if (($n % 100) == 0);
}
printf STDERR "\rUpdating database: %d/%d shapes\n", $n, scalar(@shapes);
$dbh->commit();

# Reset statistics.
$total_shape_tests = $total_queries = 0;

# Read list of postcodes and coordinates, do point-in-polygon tests for each
# one.
{
    my $n = 0;
    my $starttime = time();

    # Cache area result between postcode tests for speed.
    my %areas = ( WMC => undef, EUR => undef );

    while (defined(my $line = <STDIN>)) {
        next if $line =~ /^"Postcode",/;
        chomp $line;
        $line =~ s/\r//g; # In case it's using DOS line endings
        my @x = split(/,/, $line);
        
        my ($pc, $qual, $E, $N) = ($x[0], $x[5], $x[6], $x[7]);
        $pc =~ s/[" ]//g;

        %areas = find_containing_areas($E, $N, \%areas);

        # Sanity checks.
        foreach my $musthave (qw(WMC EUR)) {
            warn "no $musthave for $pc ($E, $N)\n" unless (defined($areas{$musthave}));
        }

        my $pcid = get_postcode_id($dbh, $pc, $E, $N);
        my $S = $areas{WMC};
        $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $S->id());

        ++$n;
        if (0 == ($n % 100)) {
            # Put this commit in to see what is happening while it runs, but lose rollback if it goes wrong            
            $dbh->commit();
            STDERR->printf("\r%d postcodes (%s); total p-in-p tests: %d; average tests/query = %f, time/query = %f", $n, $pc, $total_shape_tests, $total_shape_tests / $total_queries, (time()-$starttime) / $n) if (0 == ($n % 100));
        }
    }
    STDERR->printf("\r[2K%d postcodes\n", $n);
}

$dbh->commit();

# This function adds the row to the geometry table for the shape,
# which must already have a MaPit ID.
sub add_geometry {
    my $A = shift;
    my ($min_lat, $min_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->minx(), $A->miny(), 'G');
    my ($max_lat, $max_lon) = mySociety::GeoUtil::national_grid_to_wgs84($A->maxx(), $A->maxy(), 'G');
    my $centre_e = ($A->minx() + $A->maxx()) / 2;
    my $centre_n = ($A->miny() + $A->maxy()) / 2;
    my ($centre_lat, $centre_lon) = mySociety::GeoUtil::national_grid_to_wgs84($centre_e, $centre_n, 'G');
    my $db_id = $A->id();

    my $binary_poly; # format as documented in mapit-schema.sql
    my $parts_count = scalar(@{$A->parts()});
    my $calculated_surface_area = 0;
    foreach (@{$A->parts()}) {
        my ($sense, $vv) = @$_;
        my $vertices_count = length($vv) / (2 * doublesize());
        # print STDERR "  ... part $sense sense $vertices_count vertices\n";
        $binary_poly .= pack('i', $sense);
        $binary_poly .= pack('i', $vertices_count);
        $binary_poly .= $vv;
        
        # Calculate area from the polygon 
        my $surface_area = abs(mySociety::Polygon::poly_area($vertices_count, $vv));
        if ($sense > 0) {  
            $calculated_surface_area += $surface_area;
        } elsif ($sense < 0) {
            $calculated_surface_area -= $surface_area;
        } else {
            die "zero sense value for part in " . $A->name();
        }
    }
    die "Calculated surface zero or negative ($calculated_surface_area) for " . $A->name() if ($calculated_surface_area <= 0);

    $dbh->do("delete from area_geometry where area_id = ?", {}, $db_id);
    $dbh->do("insert into area_geometry (
            area_id, centre_e, centre_n,
            min_e, min_n, max_e, max_n,
            area, parts
        ) values (
            ?, ?, ?,
            ?, ?, ?, ?,
            ?, ?
        ) ", {}, 
            $db_id, $centre_e, $centre_n,
            $A->minx(), $A->miny(), $A->maxx(), $A->maxy(),
            0, $parts_count
        );
    #area 

    # Horrid. To insert a value into a BYTEA column we need to do a little
    # parameter-binding dance:
    my $s = $dbh->prepare(q#update area_geometry set polygon = ? where area_id = ?#);
    $s->bind_param(1, $binary_poly, { pg_type => DBD::Pg::PG_BYTEA });
    $s->bind_param(2, $db_id);
    $s->execute();
}
