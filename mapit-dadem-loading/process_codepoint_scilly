#!/usr/bin/perl -w -I../../perllib
#
# process_codepoint_scilly:
# Read CodePoint postcodes, coordinates, and ONS ward codes, and use them to
# generate a mapping from postcodes to electoral geography in the Isles of
# Scilly. COI = Council of the Isles, COP = Parish within it.
#
# Call with two arguments:
#   - CSV file generated from the ward to constituency mapping in SNAC;
#   - CSV file of postcodes and other data from CodePoint.
#
# All Scilly postcodes begin TR2, so you need TR.CSV from the CodePoint
# distribution. The SNAC ward codes are as commented in process_codepoint_ni.
#
# For example, run like this:
# ./process_codepoint_scilly snac-2003-cons2ward.csv ~/toobig/geodata-mysociety/codepoint-2004-11/tr.csv
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_codepoint_scilly,v 1.6 2005-10-04 14:12:37 dademcron Exp $';

use strict;

use Text::CSV_XS;

use Common;

# Text::CSV excludes characters outside the ASCII range from CSV values (bug
# reported two years ago, never fixed). Text::CSV_XS also has this behaviour
# by default, but offers options for a slightly less inept behaviour.
my $c = new Text::CSV_XS({ binary => 1 });

die "arguments are ONS codes CSV file, and CodePoint CSV file" unless (@ARGV == 2);

my ($onscodesfile, $codepointfile) = @ARGV;
my $dbh = connect_to_mapit_database();

# %name
# Name of anything with an ONS code.
my %name;

# %wid
# ONS ward code to area ID of parish.
my %wid;

# Hack: get local authority, constituency and Euro region, by ONS code in first
# two cases and name in the third.
$dbh->do("update area set type = 'COI' where ons_code = '15UH' and type = 'CTY'");
my $la_id = $dbh->selectrow_array("select id from area where ons_code = '15UH'");
my $const_id = $dbh->selectrow_array("select id from area, area_name where area.id = area_name.area_id and name_type = 'O' and name = 'St. Ives Co Const'");
my $euro_area_id = $dbh->selectrow_array("select id from area, area_name where area.id = area_name.area_id and name_type = 'O' and name = 'South West Euro Region'");

# Set generation for COI parent type (COP child ones set in get_area_id below)
my $gen = new_generation($dbh);
$dbh->do("update area set generation_high = ? where type = 'COI'", {}, $gen);

print STDERR "reading ward/constituency codes... ";
foreach (read_csv_file($onscodesfile, 1)) {
    # Fields are:
    #   ONS constituency code
    #                    name
    #   ONS ward code
    #            name
    #   ONS LA/UA code
    #             name
    my ($ccode, $cname, $wcode, $wname, $acode, $aname) = @$_;

    # load Scilly only
    next if ($wcode !~ m/^15UH/);

    die "undefined constituency code in '$_'" if (!defined($ccode));
    die "undefined ward code in '$_'" if (!defined($wcode));
    die "undefined LA/UA code in '$_'" if (!defined($acode));
    
    $wcode =~ s/ //g;

    if (!exists($name{$wcode})) {
        country($dbh, $wid{$wcode} = get_area_id($dbh, $wname, 'S', 'COP', $wcode, undef, undef), 'E');
    }

    $name{$wcode} ||= $wname;
}
print STDERR "done.\n";

my %unused = map { $_ => 1 } grep(/^15UH/, keys %name);

my @postcode;
my @incomplete;
my $nopos = 0;
my %cache;

my $f = new IO::File($codepointfile) or die "$codepointfile: $!";
while (defined($_ = $f->getline())) {
    chomp2($_);
    $c->parse($_) or die "unable to parse '$_'";
    # Fields:
    #   0       postcode
    #   1       accuracy code
    #   2       PO box indicator
    #   11      easting
    #   12      northing
    #   16..18  ward code
    my @f = $c->fields();

    next if ($f[2] eq 'Y');

    my $pc = $f[0];
    $pc =~ s/ //g;
    my ($E, $N) = @f[10 .. 11];
    my $ward = join('', @f[15 .. 17]);
    $ward =~ s/ //g;

    # Scilly only
    next unless ($ward =~ m#^15UH#);

    # Skip postcodes which have no positional information (PQ of 90); these are
    # mostly PO boxes and things.
    if ($f[1] == 90) {
        ++$nopos;
        next;
    }

    # Some postcodes do not have a full ward code.
    if (length($ward) != 6) {
        push(@incomplete, [$pc, $E, $N, $ward]);
        next;
    }
    
    push(@postcode, [$pc, $E, $N, $ward]);
    $cache{"$E,$N"} = $ward;

    if (!exists($name{$ward})) {
        die "no ward for code '$ward'\n";
    }

    delete($unused{$ward});
}
die "$codepointfile: $!" if ($f->error());
$f->close();

printf STDERR "got %d good, %d bad PCs and %d with no positional information\n", scalar(@postcode), scalar(@incomplete), $nopos;
printf STDERR "%d wards contained no postcodes\n", scalar(keys %unused);

# Now @postcode contains all the postcodes for which we have ward codes.
print STDERR "writing postcodes into database...\n";
my $n = 0;
foreach (@postcode) {
    ++$n;
    printf STDERR "\r%d/%d", $n, scalar(@postcode) if (0 == ($n % 100));
    my ($pc, $E, $N, $ward) = @$_;

    my $pcid = get_postcode_id($dbh, $pc, $E, $N);
    $dbh->do('delete from postcode_area where postcode_id = ?', {}, $pcid);

    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $euro_area_id);
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $const_id);
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $la_id);
    $dbh->do('insert into postcode_area (postcode_id, area_id) values (?, ?)', {}, $pcid, $wid{$ward});
}
printf STDERR "\r%d/%d\n", $n, scalar(@postcode);

print STDERR "committing changes... ";
$dbh->commit();
$dbh->disconnect();
print STDERR "done.\n";
