#!/usr/bin/perl -w
#
# process_goveval_data2:
# Import GovEval dump files for MPs/MEPs etc.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: process_goveval_data2,v 1.1 2004-11-09 08:28:28 francis Exp $';

use strict;

use DBI;
use DBD::SQLite;
use Text::CSV;

my %id_to_name;
my %id_to_type;
my %name_to_id;

my %name_index;

sub do_index ($$$) {
    my ($index, $name, $id) = @_;
    foreach (map { lc($_) } split(/[^A-Za-z]+/, $name)) {
        $index->{$_}->{$id} = 1;
    }
}

sub find_matches ($$;$) {
    my ($index, $query, $candidates) = @_;

    # Compass points.
    $query =~ s#N\.#$1 North #g;
    $query =~ s#E\.#$1 East #g;
    $query =~ s# E # East #g;
    $query =~ s#S\.#$1 South #g;
    $query =~ s#W\.#$1 West #g;
    $query =~ s#Town##;
    $query =~ s#Midd'brough#Middlesbrough#;

    $query =~ s#Southern#South#;

    my $threshold = 0.025;

    die if (!defined($query));

    my %matches;

    $query =~ s# of # #g;

    foreach my $word (map { lc($_) } split(/[^A-Za-z]+/, $query)) {
        next if (!exists($index->{$word}));
        foreach my $id (keys %{$index->{$word}}) {
            $matches{$id} += 1 / scalar(keys %{$index->{$word}});
        }
    }

    # prefer short to long matches where possible...
    foreach (keys %matches) {
        $matches{$_} /= sqrt(length($id_to_name{$_}));
    }

    # require same compass points in match as in query
    foreach my $id (keys %matches) {
        foreach my $dir (qw(north east south west)) {
            my $m = 0;
            ++$m if ($id_to_name{$id} =~ m#\b$dir\b#i);
            ++$m if ($query =~ m#\b$dir\b#i);
            delete $matches{$id} if ($m == 1);
        }
    }

    return sort { $matches{$b} <=> $matches{$a} } grep { $matches{$_} > $threshold } keys %matches;
}

my $dbh = DBI->connect('dbi:SQLite:dbname=mapit.sqlite', '', '', { AutoCommit => 0, RaiseError => 1 });

my $type = $ARGV[0];
die "specify an area type as single argument" unless ($type);

#my %name_to_id;

my $s = $dbh->prepare('select distinct area.id, area.name from area where area.type = ?');

$s->execute($type);

while (my ($id, $name) = $s->fetchrow_array()) {
    die "duplicate area \"$type\"\n" if (exists($name_to_id{$name}));
    $id_to_name{$id} = $name;
    $name_to_id{$name} = $id;
    $id_to_type{$id} = $type;

    do_index(\%name_index, $name, $id);
}

# Parse the GovEval data.
my $C = new Text::CSV;

<STDIN>;    # header line

my @data = ( );

# can't do N Irish constituencies, ignore them
my %niconsts = map { $_ => 1 } (
        "Belfast South",
        "Belfast East",
        "Strangford",
        "Antrim North",
        "Ulster Mid",
        "Down South",
        "Newry & Armagh",
        "Foyle",
        "Down North",
        "Fermanagh & South Tyrone",
        "Lagan Valley",
        "Tyrone West",
        "Belfast North",
        "Londonderry East",
        "Antrim South",
        "Antrim East",
        "Belfast West",
        "Upper Bann"
    );

while (my $line = <STDIN>) {
    local $/ = "\r\n";
    chomp($line);
    $C->parse($line) or die $C->error_input();
    my ($first, $last, $areaname, $party, $email, $fax) = $C->fields();
    next if ($niconsts{$areaname});
    push(@data, [$C->fields()]);
}

my %gename_to_id;
my %id_to_gename;
my %bad;

#unlink('dadem-new.sqlite') or die "dadem-new.sqlite: $!" if (-e 'dadem-new.sqlite');
my $d_dbh = DBI->connect('dbi:SQLite:dbname=dadem.sqlite', '', '', { AutoCommit => 0, RaiseError => 1 });
### $d_dbh->do(q#
### create table representative (
###     id integer not null primary key,
###     area_id integer not null,
###     area_type char(3) not null,
###     name text not null,
###     party text not null,
###     method integer not null,    -- 0: either, 1: fax, 2: email
###     email text,
###     fax text
### );#);

$d_dbh->do('delete from representative where area_type = ?', {}, $type);

# Obtain mapping from GovEval's constituency names to our area IDs.
foreach (@data) {
    my ($first, $last, $areaname, $party, $email, $fax) = @$_;

    next if (exists($gename_to_id{$areaname})); # seen this already
    next if (exists($bad{$areaname}));

    my @matches = find_matches(\%name_index, $areaname);

    if (!@matches) {
        warn "no matching names for $areaname\n";
        $bad{$areaname} = 1;
    } else {
        if (exists($id_to_gename{$matches[0]})) {
            warn "area $id_to_name{$matches[0]} ($matches[0]) already mapped to $id_to_gename{$matches[0]}, also matches $areaname\n";
        } else {
#            $gename_to_id{$areaname} = $matches[0];
#            $id_to_gename{$matches[0]} = $areaname;
            my $method;
            $email = undef if ($email eq '');
            $fax = undef if ($fax eq '');
            if ($email and $fax) {
                $method = 0;
            } elsif ($fax) {
                $method = 1;
            } else {
                $method = 2;
            }
            $d_dbh->do('insert into representative (area_id, area_type, name, party, method, email, fax) values (?, ?, ?, ?, ?, ?, ?)', {},
                        $matches[0],
                        $type,
                        "$first $last",
                        $party,
                        $method,
                        $email,
                        $fax);
                        
        }
    }
}

$d_dbh->commit();
$d_dbh->disconnect();

exit(0);
__END__

#print join("\n", map { "$_ = $id_to_name{$gename_to_id{$_}}" } sort keys %gename_to_id ), "\n";


# Now obtain a mapping from GovEval's ward/ED names to our area IDs.
foreach (@data) {
    my ($first, $last, $vdiv, $council, $email) = @$_;

    next unless (exists($gename_to_id{$council}));
    next if (exists($bad{$council}));

    my $comp = "$council\0$vdiv";

    # Special case for elected mayors.
    $gename_to_id{$comp} = $gename_to_id{$council} if ($vdiv eq 'Elected Mayor');

    next if (exists($bad{$comp}));
    
    if (!exists($gename_to_id{$comp})) {
        my @matches = find_matches($child_index{$gename_to_id{$council}}, $vdiv, $child_areas{$gename_to_id{$council}});

        if (@matches) {
            $gename_to_id{$comp} = $matches[0];
        } else {
            print STDERR "$council / $vdiv: no matches found; could be:\n";
            foreach (sort { $id_to_name{$a} cmp $id_to_name{$b} } keys %{$child_areas{$gename_to_id{$council}}}) {
                print STDERR "    $id_to_name{$_} ($_)\n";
            }
            $bad{$comp} = 1;
        }
    }

    if (exists($gename_to_id{$comp})) {
        $d_dbh->do("insert into representative (area_id, area_type, name, party, method, email, fax) values (?, ?, ?, '', ?, ?, ?)", {},
                    $gename_to_id{$comp},
                    $id_to_type{$gename_to_id{$comp}},
                    "$first $last",
                    2,
                    $email,
                    undef);
    }
}
$d_dbh->commit();

$dbh->disconnect();
$d_dbh->disconnect();
