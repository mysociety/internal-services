#!/usr/bin/perl
#
# boundaryline-2005-05.control:
# Control file for import of May 2005 Boundary Line.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#
# $Id: boundaryline-2005-05.control,v 1.7 2005-08-31 17:29:29 chris Exp $
#

use Text::CSV;

sub find_best_match ($$) {
    my ($name, $list) = @_;
    return (sort { Text::LevenshteinXS::distance($name, $a->name()) <=> Text::LevenshteinXS::distance($name, $b->name()) } @$list)[0];
}

# control_function SHAPES ONSCODE AREATYPE
# Function called to fix up BL.
sub control_function ($$$) {
    my ($shapes, $onscode_idx, $area_type_idx) = @_;

    # Wards in the Borough of Stockton-on-Tees have changed.
    foreach (@{$area_type_idx->{UTW}}) {
        $_->deleted(1) if ($_->ons_code() =~ /^00EF/);
    }

    # New Boundary Line codes the Isles of Scilly as a county. We don't,
    # instead treating them as a special case, which is what they are.
    my $ios = find_best_match('Isles of Scilly', $area_type_idx->{CTY});
    foreach ($ios, $ios->children()) {
        $_->deleted(1);
    }

    #
    # Boundary changes in English counties.
    #

    # Mark as new all English CEDs.
    foreach (@{$area_type_idx->{CED}}) {
        $_->alreadyexists(0);
    }

    # Delete CEDs in counties for which the SIs have not been included in this
    # edition of BL.
    foreach my $cty (@{$area_type_idx->{CTY}}) {
        next unless ($cty->name() =~ /^(Buckinghamshire|Cambridgeshire|Cornwall|Durham|Lancashire|Leicestershire|Norfolk|North Yorkshire|West Sussex|Worcestershire)/);
        foreach my $ced ($cty->children()) {
            $ced->deleted(1);
        }
    }

    # For those counties, we need to construct the new CEDs from existing
    # areas, so far as that is possible.
    open(C, "boundaryline-2005-05-missing-CEDs.csv") or die "can't read CEDs CSV file: $!";
    my $C = new Text::CSV();

    my %cedscreated;
    my %districts;

    while (defined (my $line = <C>)) {
        chomp($line);
        $C->parse($line);
        my ($county, $district, $ced, $ward, $parish, $parishward) = $C->fields();
        my $shape;
        if (!exists($cedscreated{$county}->{$ced})) {
            my ($cty) = grep { $_->name() =~ /\Q$county\E/ } @{$area_type_idx->{CTY}};
            die "can't find shape for county '$county'" unless ($cty);
        
            my $a = new Area(area_type => 'CED', name => "$ced ED", devolved => 'E', country => 'E', minx => 10000000, maxx => 0, miny => 10000000, maxy => 0, alreadyexists => 0, parts => [ ]);
            $cty->children($a);
            push(@$shapes, $a);
            push(@{$area_type_idx->{CED}}, $a);
            $shape = $cedscreated{$county}->{$ced} = $a;

            print STDERR "Creating new CED: ", $shape->name(), " in $county\n";
        }

        # Need to identify the associated district.
        if (!exists($districts{$district})) {
            my $dis = find_best_match($district, $area_type_idx->{DIS});
            print STDERR "district '$district' -> DIS ", $dis->name(), "\n";
            $districts{$district} = $dis;
        }

        my $othershape;
        if (defined($ward)) {
            my $othershape = find_best_match($ward, [grep { $_->area_type() eq 'DIW' } $districts{$district}->children()]);
            print STDERR "  CED contains ward ", $othershape->name(), "\n";
        } elsif (defined($parish) && !defined($parishward)) {
            my $othershape = find_best_match($parish, [grep { $_->area_type() eq 'CPC' } $districts{$district}->children()]);
            print STDERR "  CED contains parish ", $othershape->name(), "\n";
        } else {
            # anything else: can't cope with this
            print STDERR "  CED contains area we can't deal with\n";
        }

        if (defined($othershape)) {
            push(@{$shape->parts()}, @{$othershape->parts()});
            $shape->minx($othershape->minx()) if ($othershape->minx() < $shape->minx());
            $shape->miny($othershape->miny()) if ($othershape->miny() < $shape->miny());
            $shape->maxx($othershape->maxx()) if ($othershape->maxx() > $shape->maxx());
            $shape->maxy($othershape->maxy()) if ($othershape->maxy() > $shape->maxy());
            $shape->cx($othershape->cx()) if (!defined($shape->cx()));
            $shape->cy($othershape->cy()) if (!defined($shape->cy()));
        }
    }

    close(C);

    #
    # Scottish constituencies.
    #
    foreach my $wmc (@{$area_type_idx->{WMC}}) {
        $wmc->deleted(1) if ($wmc->country() eq 'S');
    }

    # The new constituencies are made up of whole council wards, but each
    # constituency may be described by a list of wards or by referring to that
    # part of a council which has not already been assigned to other
    # constituencies.

    my (%council_name, %ward_name, %constituency_name);

    # council name -> constituency for leftover bits of that council
    my %council_to_constituency;
    # council name -> ward name -> constituency for that ward
    my %ward_to_constituency;

    # Read CSV file which identifies the UTW wards which make up each new
    # Scottish constituency.
    open(C, "new-scottish-constituencies-council-wards.csv") or die "can't read WMCs CSV file: $!";
    <C>;    # skip header

    my ($last_constituency, $last_council);
    while (my $line = <C>) {
        chomp($line);
        $C->parse($line);
        my ($constituency, $council, $ward) = $C->fields();

        die "no constituency at top of file" unless ($constituency || $last_constituency);
        die "no council at top of file" unless ($council || $last_council);

        $ward = "$ward Ward" unless ($ward eq '*');

        $constituency ||= $last_constituency;
        $council ||= $last_council;

        $constituency_name{$constituency} = 1;

        $council_name{$council} = 1;
        $ward_name{$council}->{$ward} = 1 unless ($ward eq '*');

        $ward_to_constituency{$council} ||= { };

        if ($ward eq '*') {
            die "constituency '$constituency': council '$council' already has a residue constituency, '$council_to_constituency{$council}'" if (exists($council_to_constituency{$council}));
            $council_to_constituency{$council} = $constituency;
        } else {
            die "constituency '$constituency': ward '$ward' in council '$council' is already assigned to constituency '$ward_to_constituency{$council}->{$ward}'"
                if (exists($ward_to_constituency{$council}->{$ward}));
            $ward_to_constituency{$council}->{$ward} = $constituency;
        }
        
        $last_constituency = $constituency;
        $last_council = $council;
    }

    close(C);

    # Match named councils and wards to shapes.
    foreach my $name (keys %council_name) {
        my $shape = find_best_match($name, [grep { $_->country() eq 'S' } @{$area_type_idx->{UTA}}]);
        print STDERR "unitary authority $name -> ", $shape->name(), "\n";
        $council_name{$name} = $shape;
    }

    foreach my $council (keys %ward_name) {
        print STDERR "wards in $council...\n";
        foreach my $ward (keys %{$ward_name{$council}}) {
            my $shape = find_best_match($ward, [$council_name{$council}->children()]);
            $ward_name{$council}->{$ward} = $shape;
            print "    ward $ward -> ", $shape->name(), "\n";
        }
    }

    # Now construct a shape for each constituency and form it from the wards of
    # which it's composed.
    foreach my $name (keys %constituency_name) {
        # Match OS naming convention. Scotland has "Burgh Constituencies"
        # rather than "Boro[ugh] Constituencies".
        my $osname = $name;
        $osname =~ s/Burgh Constituency$/Burgh Const/;
        $osname =~ s/County Constituency$/Co Const/;
        my $a = new Area(area_type => 'WMC', name => $osname, devolved => 'S', country => 'S', minx => 10000000, maxx => 0, miny => 10000000, maxy => 0, alreadyexists => 1, parts => [ ]);
        push(@$shapes, $a);
        push(@{$area_type_idx->{WMC}}, $a);
        $constituency_name{$name} = $a;
    }

    foreach my $council (keys %council_name) {
        # Go through all of the wards in this council.
        foreach my $w ($council_name{$council}->children()) {
            my $constituency = $council_to_constituency{$council};
            foreach my $w2 (keys %{$ward_name{$council}}) {
                if ($ward_name{$council}->{$w2} == $w) {
                    $constituency = $ward_to_constituency{$council}->{$w2};
                    last;
                }
            }

            if (!defined($constituency)) {
                die "no constituency defined for $council, " . $w->name() . "\n";
            }

            my $shape = $constituency_name{$constituency};
            print STDERR "$council, ", $w->name(), " added to ", $shape->name(), "\n";
            
            my $othershape = $w;

            push(@{$shape->parts()}, @{$othershape->parts()});
            $shape->minx($othershape->minx()) if ($othershape->minx() < $shape->minx());
            $shape->miny($othershape->miny()) if ($othershape->miny() < $shape->miny());
            $shape->maxx($othershape->maxx()) if ($othershape->maxx() > $shape->maxx());
            $shape->maxy($othershape->maxy()) if ($othershape->maxy() > $shape->maxy());
            $shape->cx($othershape->cx()) if (!defined($shape->cx()));
            $shape->cy($othershape->cy()) if (!defined($shape->cy()));
        }
    }
}

1;
