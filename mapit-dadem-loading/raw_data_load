#!/usr/bin/perl -w -I../../perllib
#
# load_raw_wards
# Load in raw GovEval data, match Council names names to Ordnance Survey ones
# in the MaPit database, and use appropriate IDs.  Loads the canonical names of
# councils into MaPit.
#
# Parameters:  Pipe the councillorsWithID.csv file from GovEval into standard
# input.
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: raw_data_load,v 1.9 2005-07-14 17:51:05 francis Exp $';

use strict;
$| = 1; # flush STDOUT afer each write

use DBI;
use DBD::Pg;
use Text::CSV;
use Data::Dumper;
use mySociety::VotingArea;
use mySociety::CouncilMatch;
use mySociety::ArrayUtils;

use Common;

my $m_dbh = connect_to_mapit_database();
my $d_dbh = connect_to_dadem_database();
mySociety::CouncilMatch::set_db_handles($m_dbh, $d_dbh);

# Delete existing GovEval name data for councils of 'C' type
$m_dbh->do(
        q#delete from area_name where area_id in (select area_id from area where
            (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)) 
            and name_type = ?;#, {}, 'C'
);

# %parent_to_id
# Hash of council canonical name to council ID from existing MaPit data.
my %parent_to_id;

# Cache of area_id->type etc.
my $area_id_data = $m_dbh->selectall_hashref(
        q#select * from area
            where 
            (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)#,
        'id');

# Cache of name-->id map of all the parent area types (District Council,
# Unitary Authority etc....)
my $s = $m_dbh->prepare(
        q#select area_id, name from area_name, area
            where area_name.area_id = area.id
            and (name_type = 'O' or name_type = 'S')
            and (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)#
    );
$s->execute();

while (my ($area_id, $name) = $s->fetchrow_array()) {
    # Create canonical version of name and also hash it as lookup
    my $canon = mySociety::CouncilMatch::canonicalise_council_name($name);
    #print "dbname $name $area_id canon $canon\n";
    if (exists($parent_to_id{$canon})) {
        if ($parent_to_id{$canon} != $area_id) {
            die "Already have id for canonicalised $canon, being " .  $parent_to_id{$canon} .  "\n";
        }
    } else {
        $parent_to_id{$canon} = $area_id;

        # Store in database as 'C' record
        $m_dbh->do("insert into area_name (area_id, name_type, name) values (?, ?, ?)", {}, $area_id, 'C', $canon);
    }
}
 
# Load the GovEval data.
my $C = new Text::CSV;
my $line_number = 0;
<STDIN>;    # header line
$line_number++;

# $councils
# Reference to hash of council ID to reference to hash of information about the
# council, including:
#   canonname       its canonical name
#   govevalname     its GovEval name
my $councils;

while (my $line = <STDIN>) {
    $line_number++;

    # Remove bad control characteres
    chomp($line);
    $line =~ s/\xA0//g; # appears twice after "Castle Baynard"
    $line =~ s/\x0B//g; # appears after some email addresse
    $line =~ s/\x14ina/Tina/g; # strangely broken "T"
    $line =~ s/\x00//g; # appears on the last line
    next if $line =~ m/^\s*$/;

    # Extract good stuff
    $C->parse($line);
    my @line = map { trim_spaces($_) } $C->fields();
    my ($geid, $first, $last, $vdiv, $council, $party, $fax, $email, $councilfax, $councilemail) = @line;

    die "council not defined\nline $line_number: $line\n" unless (defined($council));
    warn "invalid geid $geid\nline $line_number: $line\n" unless $geid =~ m/^[1-9][0-9]+$/;
    warn "first name is empty geid $geid" if !$first;
    warn "last name is empty geid $geid" if !$last;
    warn "ward name is empty geid $geid" if !$vdiv;

    # Special case for areas with elected mayors.
    next if $vdiv eq "Elected Mayor";
    
    my $canon = mySociety::CouncilMatch::canonicalise_council_name($council);
    #print "gename $council canon $canon\n";

    die "no council in database matches canonical name '$canon'\nline $line_number: $line" unless (exists($parent_to_id{$canon}));

    my $id = $parent_to_id{$canon};
    
    $councils->{$id}->{canonname} = $canon;
    $councils->{$id}->{govevalname} = $council;
    push @{$councils->{$id}->{lines}}, \@line;
}

# Print out councils in $parent_to_id for which nobody has been added to $councils
my @ck = keys %$councils;
my @pk = keys %parent_to_id;
if ($#ck != $#pk) {
    print STDERR "Council count mismatch:\n";
    print STDERR "There are " . scalar(@ck) . " councils in GovEval data\n";
    print STDERR "There are " . scalar(@pk) . " councils in database\n";

    my %p = %parent_to_id;
    foreach (keys %$councils) {
        delete($p{$councils->{$_}->{canonname}});
    }

    print STDERR "Database councils not matched:\n", join("\n", sort keys %p), "\n";
}
foreach my $parent (@pk) {
    my $id = $parent_to_id{$parent};
    die "\$parent_to_id{'$parent'} not present" unless (defined($id));
    if (!exists($councils->{$id})) {
        print STDERR "Missing $parent id $id from GovEval data\n"; 
    }
}

# Load data into raw table in DaDem
my $councils_count = 0;
foreach my $council_id (keys %$councils) {
    $councils_count++;

    # Get data we loaded last time, i.e. before mySociety edits
    my $sth = $d_dbh->prepare(q#select ge_id, ward_name, 
                  rep_first, rep_last, rep_party, rep_email, rep_fax
                  from raw_input_data where council_id = ?#, {});
    $sth->execute($council_id);
    my $reps_prev_import;
    while (my $rep = $sth->fetchrow_hashref) {
        my $key = 'ge_id' . $rep->{ge_id};
        $reps_prev_import->{$key} = $rep;
        $reps_prev_import->{$key}->{key} = $key;
    }

    # Get each line of new import
    my $lines = $councils->{$council_id}->{lines};
    my $reps_new_import;
    foreach my $line (@$lines) {
        my ($geid, $first, $last, $vdiv, $council, $party, $fax, $email, $councilfax, $councilemail) = @$line;
        $fax = ""; $email = ""; # Fax and email data isn't good enough to use
        $geid =~ s/[^0-9]//g;
        die "digit part of geid too short\nline $line_number: $line\n" unless scalar($geid) > 3;
        my $key = 'ge_id' . $geid;
        $reps_new_import->{$key}->{key} = $key;
        $reps_new_import->{$key}->{ward_name} = $vdiv;
        $reps_new_import->{$key}->{rep_first} = $first;
        $reps_new_import->{$key}->{rep_last} = $last;
        $reps_new_import->{$key}->{rep_party} = $party;
        $reps_new_import->{$key}->{rep_email} = $email;
        $reps_new_import->{$key}->{rep_fax} = $fax;
    }
    
    # Get data as modified by mySociety
    my @reps_mysociety_mod = mySociety::CouncilMatch::get_raw_data($council_id);
    my $reps_mysociety_mod;
    foreach my $rep (@reps_mysociety_mod) {
        $reps_mysociety_mod->{$rep->{key}} = $rep;
    }

    # Display
    print "-" x 70 . "\n";
    print $councils->{$council_id}->{canonname} . " " . $area_id_data->{$council_id}->{type} . " id:$council_id" . "\n";

    #print "prev import:\n";
    #print Dumper($reps_prev_import);
    #print "mysociety mods:\n";
    #print Dumper($reps_mysociety_mod);
    #print "new import:\n";
    #print Dumper($reps_new_import);

    # Returns string containing differences between two representative records, or empty
    # string (which is "false") if there are no differences.
    my $reps_diff = sub {
        my ($rep1, $rep2) = @_;

        my $diff = "";
        foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
            if ($rep1->{$field} ne $rep2->{$field}) {
                $diff .= "$field: '".$rep1->{$field}."'->'".$rep2->{$field}."' ";
            }
        }
        return $diff;
    };

    # Returns description of rep
    my $rep_desc = sub {
        my ($rep) = @_;
        return $rep->{ward_name} . ", ".$rep->{rep_first}." ".$rep->{rep_last}." (".$rep->{rep_party}.")";
    };

    # Look for differences in the keys
    my $common_keys;
    my $diff_mysociety_new = mySociety::ArrayUtils::symmetric_diff([keys %$reps_mysociety_mod], [keys %$reps_new_import]);
    if (scalar(@$diff_mysociety_new) > 0) {
        print "clashes through addition/deletion of ge_id, symmetric diff " . scalar(@$diff_mysociety_new) . "\n";
        # See what the additions/deletions are
        foreach my $key (@$diff_mysociety_new) {
            my $in_mysociety = defined($reps_mysociety_mod->{$key});
            my $in_new = defined($reps_new_import->{$key});
            my $in_prev = defined($reps_prev_import->{$key});
            if ($in_mysociety && !$in_new) {
                if ($in_prev) {
                    print "GE deleted $key\n";
                    print "\t".$rep_desc->($reps_mysociety_mod->{$key})."\n";
                } else {
                    print "MS added $key\n";
                    print "\t".$rep_desc->($reps_mysociety_mod->{$key})."\n";
                }
            } elsif ($in_new && !$in_mysociety) {
                if ($in_prev) {
                    print "MS deleted $key\n";
                    print "\t".$rep_desc->($reps_new_import->{$key})."\n";
                } else {
                    print "GE added $key\n";
                    print "\t".$rep_desc->($reps_new_import->{$key})."\n";
                }
            } else {
                die "symmetric diff must be in one of them";
            }
        }

        # Keys which remained in both fields throughout
        $common_keys = mySociety::ArrayUtils::intersection([keys %$reps_mysociety_mod], [keys %$reps_new_import]);
    } else {
        # In this case, other diffs should find no alterations (as serious mySociety mods make their own new keys)
        my $diff_mysociety_prev = mySociety::ArrayUtils::symmetric_diff([keys %$reps_mysociety_mod], [keys %$reps_prev_import]);
        die "expected no diffs" if scalar(@$diff_mysociety_prev) > 0;
        my $diff_new_prev = mySociety::ArrayUtils::symmetric_diff([keys %$reps_new_import], [keys %$reps_prev_import]);
        die "expected no diffs" if scalar(@$diff_new_prev) > 0;

        # Keys match, so use them all
        print "OK, keys match\n";
        $common_keys = [keys %$reps_new_import];
    }
    
    # Loop through all representatives, merging changes
    foreach my $key (@$common_keys) {
        my $new_import = $reps_new_import->{$key};
        my $mysociety_mod = $reps_mysociety_mod->{$key};
        my $prev_import = $reps_prev_import->{$key};

        my $mysociety_new = $reps_diff->($mysociety_mod, $new_import);
        my $prev_mysociety = $reps_diff->($prev_import, $mysociety_mod);
        my $prev_new = $reps_diff->($prev_import, $new_import);

        if ($mysociety_new) {
            # Differ
            #print "Difference MS->GE: $mysociety_new\n";
            if ($prev_mysociety && !$prev_new) {
                print "Pick MS, as GE no change\n";
                print "\tMS change: $prev_mysociety\n";
            } elsif ($prev_new && !$prev_mysociety) {
                print "Pick GE, as MS no change\n";
                print "\tGE change: $prev_new\n";
            } else {
                die if (!$prev_new || !$prev_mysociety);
                print "PROPER CLASH both changed\n";
                print "\tMS change: $prev_mysociety\n";
                print "\tGE change: $prev_new\n";
            }
            #print Dumper($new_import);
            #print Dumper($mysociety_mod);
        } else {
            # Same
            if ($prev_mysociety || $prev_new) {
                print "Both made same change\n";
                print "\tMS change: $prev_mysociety\n";
                print "\tGE change: $prev_new\n";
            }
        }
    }

    # Vague but doomed attempt to delete existing data (doesn't behave as we
    # would want when ids and names and types change, because we don't yet
    # know what we want)
#$d_dbh->do(q#delete from raw_input_data where council_id = ? #, {}, $council_id);
#$d_dbh->do(q#delete from raw_input_data_edited where council_id = ? #, {}, $council_id);
    # Insert new data
#        $d_dbh->do(q#insert into raw_input_data
#                (ge_id, council_id, council_name, council_type, council_ons_code, ward_name, 
#                    rep_first, rep_last, rep_party, rep_email, rep_fax)
#                values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)#, {}, 
#                $geid, $council_id, $councils->{$council_id}->{canonname}, $area_id_data->{$council_id}->{type}, 
#                $area_id_data->{$id}->{ons_code}, $vdiv, 
#                $first, $last, $party, $email, $fax);

}

#$m_dbh->commit();
#$d_dbh->commit();
#$m_dbh->disconnect();
#$d_dbh->disconnect();

