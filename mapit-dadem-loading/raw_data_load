#!/usr/bin/perl -w -I../../perllib
#
# raw_data_load
# Load in raw GovEval data, match Council names names to Ordnance Survey ones
# in the MaPit database, and use appropriate IDs.  Loads the canonical names of
# councils into MaPit.
#
# If an import has been done before to the database, it does a merge with any
# changes made since them.  This can be safely done repeatedly with the same
# data.  The merge automatically is made relative to the last import.
# Conflicts are marked in the merged fields with the text CONFLICT.
#
# Parameters:  Pipe the councillorsWithID.csv file from GovEval into standard
# input.
#
# cat ../../../repdata/goveval/councillorsWithID.csv | ./raw_data_load
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: raw_data_load,v 1.18 2005-09-14 15:41:44 francis Exp $';

use strict;
require 5.8.0;

$| = 1; # flush STDOUT afer each write

use DBI;
use DBD::Pg;
use Text::CSV;
use Data::Dumper;
use mySociety::VotingArea;
use mySociety::CouncilMatch;
use mySociety::ArrayUtils;
use Encode;
use Storable;

use Common;

my $m_dbh = connect_to_mapit_database();
my $d_dbh = connect_to_dadem_database();
mySociety::CouncilMatch::set_db_handles($m_dbh, $d_dbh);

my $generation = $m_dbh->selectrow_array('select id from current_generation');

# values from 0 to 3 with increasing verbosity
my $verbose = 3;

# Delete existing GovEval name data for councils of 'C' type
$m_dbh->do(
        qq#delete from area_name where area_id in (select area_id from area where
            generation_low <= $generation and $generation <= generation_high and
            (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)) 
            and name_type = ?;#, {}, 'C'
);

# %parent_to_id
# Hash of council canonical name to council ID from existing MaPit data.
my %parent_to_id;

# Cache of area_id->type etc.
my $area_id_data = $m_dbh->selectall_hashref(
        qq#select * from area
            where 
            generation_low <= $generation and $generation <= generation_high and
            (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)#,
        'id');

# Cache of name-->id map of all the parent area types (District Council,
# Unitary Authority etc....)
my $s = $m_dbh->prepare(
        qq#select distinct area_id, name from area_name, area
            where area_name.area_id = area.id and
            generation_low <= $generation and $generation <= generation_high
            and (name_type = 'O' or name_type = 'S')
            and (# . join(' or ', map { "type = '$_'" } @$mySociety::VotingArea::council_parent_types) . q#)#
    );
$s->execute();

while (my ($area_id, $name) = $s->fetchrow_array()) {
    # Create canonical version of name and also hash it as lookup
    my $canon = mySociety::CouncilMatch::canonicalise_council_name($name);
    print "#$area_id '$name' -> '$canon'\n";
    if (exists($parent_to_id{$canon})) {
        if ($parent_to_id{$canon} != $area_id) {
            die "Already have id for canonicalised $canon, being " .  $parent_to_id{$canon} .  "\n";
        }
    } else {
        $parent_to_id{$canon} = $area_id;

        # Store in database as 'C' record
        $m_dbh->do("insert into area_name (area_id, name_type, name) values (?, ?, ?)", {}, $area_id, 'C', $canon);
    }
}
 
# Load the GovEval data.
my $C = new Text::CSV;
my $line_number = 0;
<STDIN>;    # header line
$line_number++;

# $councils
# Reference to hash of council ID to reference to hash of information about the
# council, including:
#   canonname       its canonical name
#   govevalname     its GovEval name
my $councils;

while (my $line = <STDIN>) {
    $line_number++;

    # Remove bad control characteres
    chomp($line);
    $line =~ s/\xA0//g; # appears twice after "Castle Baynard"
    $line =~ s/\x0B//g; # appears after some email addresse
    $line =~ s/\x14ina/Tina/g; # strangely broken "T"
    $line =~ s/\x00//g; # appears on the last line
    $line =~ s/f\x83ch/fach/g; # ward in Powys
    next if $line =~ m/^\s*$/;

    # Extract good stuff
    $C->parse($line);
    my @line = map { trim_spaces($_) } $C->fields();
    my ($geid, $first, $last, $vdiv, $council, $party, $fax, $email, $councilfax, $councilemail) = @line;

    die "council not defined\nline $line_number: $line\n" unless (defined($council));
    warn "invalid geid $geid\nline $line_number: $line\n" unless $geid =~ m/^[1-9][0-9]+$/;
    next if (!$first && !$last && $vdiv);  # GovEval sometimes use this to mark pending byelection, so no member ...
    # ... we still check we don't have individual empty strings
    warn "first name is empty geid $geid" if !$first;
    warn "last name is empty geid $geid" if !$last;
    warn "ward name is empty geid $geid" if !$vdiv;

    # Special case for areas with elected mayors.
    next if $vdiv eq "Elected Mayor";
    
    my $canon = mySociety::CouncilMatch::canonicalise_council_name($council);
    #print "gename $council canon $canon\n";

    die "no council in database matches canonical name '$canon'\nline $line_number: $line" unless (exists($parent_to_id{$canon}));

    my $id = $parent_to_id{$canon};
    
    $councils->{$id}->{canonname} = $canon;
    $councils->{$id}->{govevalname} = $council;
    push @{$councils->{$id}->{lines}}, \@line;
}

# Print out councils in $parent_to_id for which nobody has been added to $councils
foreach my $parent (keys %parent_to_id) {
    my $id = $parent_to_id{$parent};
    die "\$parent_to_id{'$parent'} not present" unless (defined($id));
    if (!exists($councils->{$id})) {
        print STDERR "Missing $parent id $id from GovEval data\n"; 
    }
}

# Load data into raw table in DaDem
my $councils_count = 0;
my $clashes_count = 0;
foreach my $council_id (keys %$councils) {
print "doing $council_id\n";
    $councils_count++;
    my $this_clashes = "";

    #################################################################
    # Utility functions
    
    # Returns string containing differences between two representative records, or empty
    # string (which is "false") if there are no differences.
    my $reps_diff = sub {
        my ($rep1, $rep2) = @_;

        my $diff = "";
        foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
            if ($rep1->{$field} ne $rep2->{$field}) {
                $diff .= "$field: '".$rep1->{$field}."'->'".$rep2->{$field}."' ";
            }
        }
        return $diff;
    };

    # Returns description of rep
    my $rep_desc = sub {
        my ($rep) = @_;
        return $rep->{ward_name} . ", ".$rep->{rep_first}." ".$rep->{rep_last}." (".$rep->{rep_party}.")";
    };

    #################################################################
    # Get the three versions of data

    # Get data we loaded last time, i.e. before mySociety edits
    # We use the second parameter to get_raw_data to do this -- it gives the 
    # state just after the user "import" last edited things.
    my @reps_prev_import = mySociety::CouncilMatch::get_raw_data($council_id, 1);
    my $reps_prev_import;
    foreach my $rep (@reps_prev_import) {
        $reps_prev_import->{$rep->{key}} = $rep;
    }

    # Get data as modified by mySociety
    my @reps_mysociety_mod = mySociety::CouncilMatch::get_raw_data($council_id);
    my $reps_mysociety_mod;
    foreach my $rep (@reps_mysociety_mod) {
        $reps_mysociety_mod->{$rep->{key}} = $rep;

        # Revert any unresolved conflits back to before their resolution
        my $conflict = 0;
        foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
            my $value = $rep->{$field};
            $conflict = 1 if ($value =~ m/CONFLICT/);
        }
        if ($conflict) {
            #print "Conflict flipping\n";
            #print Dumper($reps_mysociety_mod->{$rep->{key}});
            #print Dumper($reps_prev_import->{$rep->{key}});
            if (!defined($reps_prev_import->{$rep->{key}})) {
                delete $reps_mysociety_mod->{$rep->{key}};
            } else {
                $reps_mysociety_mod->{$rep->{key}} = $reps_prev_import->{$rep->{key}};
            }
        }
    }

    # Get each line of new import
    my $lines = $councils->{$council_id}->{lines};
    my $reps_new_import;
    foreach my $line (@$lines) {
        my ($geid, $first, $last, $vdiv, $council, $party, $fax, $email, $councilfax, $councilemail) = @$line;
        $fax = ""; $email = ""; # Fax and email data isn't good enough to use
        $geid =~ s/[^0-9]//g;
        die "digit part of geid too short\nline $line_number: $line\n" unless scalar($geid) > 3;
        my $key = 'ge_id' . $geid;
        $reps_new_import->{$key}->{key} = $key;
        $reps_new_import->{$key}->{ward_name} = $vdiv;
        $reps_new_import->{$key}->{rep_first} = $first;
        $reps_new_import->{$key}->{rep_last} = $last;
        $reps_new_import->{$key}->{rep_party} = $party;
        $reps_new_import->{$key}->{rep_email} = $email;
        $reps_new_import->{$key}->{rep_fax} = $fax;
    }
    
    # Display
    my $out = "";
    $out .= "-" x 70 . "\n";
    $out .= $councils->{$council_id}->{canonname} . " " . $area_id_data->{$council_id}->{type} . " id:$council_id" . "\n";

    #print "prev import:\n";
    #print Dumper($reps_prev_import);
    #print "mysociety mods:\n";
    #print Dumper($reps_mysociety_mod);
    #print "new import:\n";
    #print Dumper($reps_new_import);

    #################################################################

    # This is where we store what we will write to the database.  We work from
    # the new GE data ($reps_new_import), and import in appropriate mySociety
    # changes.
    my $reps_merged = Storable::dclone($reps_new_import);

    #################################################################
    # Find keys which are added/deleted by either mySociety or GE,
    # and resolve what to have in reps_merged.

    # Look for differences in the keys
    my $common_keys;
    my $diff_mysociety_new = mySociety::ArrayUtils::symmetric_diff([keys %$reps_mysociety_mod], [keys %$reps_new_import]);
    my $ge_add_del = 0;
    my $ms_add_del = 0;
    my $ge_change = 0;
    my $ms_change = 0;
    if (scalar(@$diff_mysociety_new) > 0) {
        # See what the additions/deletions are
        foreach my $key (@$diff_mysociety_new) {
            my $new_import = $reps_new_import->{$key};
            my $mysociety_mod = $reps_mysociety_mod->{$key};
            my $prev_import = $reps_prev_import->{$key};
            my $in_new = defined($new_import);
            my $in_mysociety = defined($mysociety_mod);
            my $in_prev = defined($prev_import);
            if ($in_mysociety && !$in_new) {
                if ($in_prev) {
                    $out .= "GE deleted:";
                    $out .= " ".$rep_desc->($reps_prev_import->{$key})."\n";
                    $ge_add_del = 1;
                    my $prev_mysociety = $reps_diff->($prev_import, $mysociety_mod);
                    if ($prev_mysociety) {
                        $reps_merged->{$key} = Storable::dclone($prev_import);
                        foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
                            if ($mysociety_mod->{$field} ne $prev_import->{$field}) {
                                $reps_merged->{$key}->{$field} = "CONFLICT MS: " . $prev_import->{$field} .
                                    "->". $mysociety_mod->{$field} . " GE: DELETED COUNCILLOR ENTIRELY";
                            }
                        }                    
                        $out .= "\tPROPER CLASH: but MS modified: $prev_mysociety\n";
                        $this_clashes .= "Deletion modified by other. ";
                        $ms_change = 1;
                    }
                } else {
                    $reps_merged->{$key} = Storable::dclone($reps_mysociety_mod->{$key});
                    $out .= "MS added:" if $verbose > 1;
                    $out .= " ".$rep_desc->($reps_mysociety_mod->{$key})."\n";
                    $ms_add_del = 1;
                }
            } elsif ($in_new && !$in_mysociety) {
                if ($in_prev) {
                    delete $reps_merged->{$key};
                    $out .= "MS deleted:" if $verbose > 0;
                    $out .= " ".$rep_desc->($reps_prev_import->{$key})."\n";
                    $ms_add_del = 1;
                    my $prev_new = $reps_diff->($prev_import, $new_import);
                    if ($prev_new) {
                        $reps_merged->{$key} = Storable::dclone($prev_import);
                        foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
                            if ($new_import->{$field} ne $prev_import->{$field}) {
                                $reps_merged->{$key}->{$field} = "CONFLICT MS: DELETED COUNCILLOR ENTIRELY" . 
                                    " GE: " . $prev_import->{$field} .  "->". $new_import->{$field};
                            }
                        }                    
                        $out .= "\tPROPER CLASH: but GE modified: $prev_new\n";
                        $this_clashes .= "Deletion modified by other. ";
                        $ge_change = 1;
                    }
                } else {
                    $out .= "GE added:";
                    $out .= " ".$rep_desc->($reps_new_import->{$key})."\n";
                    $ge_add_del = 1;
                }
            } else {
                die "symmetric diff must be in one of them, $key";
            }
        }
        
        # What to do about deletion clashes
        if ($ge_add_del && $ms_add_del) {
            # TODO: Maybe make this a CONFLICT somehow?
            $this_clashes .= "Both made major additions/deletions. ";
        }

        # Keys which remained in both fields throughout
        $common_keys = mySociety::ArrayUtils::intersection([keys %$reps_mysociety_mod], [keys %$reps_new_import]);
    } else {
        # In this case, other diffs should find no additions (as serious mySociety mods make their own new keys),
        # and only deletions which have happened in both sets of changes.  So, symmetric diff same for both.
        my $diff_mysociety_prev = mySociety::ArrayUtils::symmetric_diff([keys %$reps_mysociety_mod], [keys %$reps_prev_import]);
        my $diff_new_prev = mySociety::ArrayUtils::symmetric_diff([keys %$reps_new_import], [keys %$reps_prev_import]);
        if (scalar(@$diff_mysociety_prev) > 0 || scalar(@$diff_new_prev) > 0) {
            my $d = mySociety::ArrayUtils::symmetric_diff($diff_mysociety_prev, $diff_new_prev);
            if (scalar(@$d) > 0) {
                die "Internally inconsistent changes:" . 
                    " diff_mysociety_prev: " . join(", ", @$diff_mysociety_prev) .
                    " diff_mysociety_prev: " . join(", ", @$diff_new_prev);
            }
        }

        # Keys match, so use them all
        $common_keys = [keys %$reps_new_import];
    }

    #################################################################
    # For common keys, merge changes
    
    # Loop through all representatives, merging changes
    foreach my $key (@$common_keys) {
        my $new_import = $reps_new_import->{$key};
        my $mysociety_mod = $reps_mysociety_mod->{$key};
        my $prev_import = $reps_prev_import->{$key};

        my $mysociety_new = $reps_diff->($mysociety_mod, $new_import);
        my $prev_mysociety = $reps_diff->($prev_import, $mysociety_mod);
        my $prev_new = $reps_diff->($prev_import, $new_import);

        if ($mysociety_new) {
            # Differ
            if ($prev_mysociety && !$prev_new) {
                # Pick MS, as GE no change
                $reps_merged->{$key} = Storable::dclone($reps_mysociety_mod->{$key});
                $out .= "MS change: $prev_mysociety\n";
                $ms_change = 1;
            } elsif ($prev_new && !$prev_mysociety) {
                # Pick GE, as MS no change
                $out .= "GE change: $prev_new\n";
                $ge_change = 1;
            } else {
                die if (!$prev_new || !$prev_mysociety);
                foreach my $field ('ward_name', 'rep_first', 'rep_last', 'rep_party', 'rep_email', 'rep_fax') {
                    next if ($mysociety_mod->{$field} eq $new_import->{$field});
                    if ( ($mysociety_mod->{$field} ne $prev_import->{$field})
                        && ($new_import->{$field} ne $prev_import->{$field})) {
                        $reps_merged->{$key}->{$field} = "CONFLICT: " .  $prev_import->{$field} . " ->" .
                                " MS: " . $mysociety_mod->{$field} . 
                                " GE: " . $new_import->{$field};
                    } elsif ($mysociety_mod->{$field} ne $prev_import->{$field}) {
                        $reps_merged->{$key}->{$field} = "CONFLICT" . 
                                " MS: " .  $prev_import->{$field} . " ->" . $mysociety_mod->{$field} . 
                                " GE: no change";
                    } elsif ($new_import->{$field} ne $prev_import->{$field}) {
                        $reps_merged->{$key}->{$field} = "CONFLICT MS: no change" .
                            " GE: " . $prev_import->{$field} . " ->" . $new_import->{$field};
                    }
                }
                $out .= "PROPER CLASH both changed\n";
                $out .= "\tMS change: $prev_mysociety\n";
                $out .= "\tGE change: $prev_new\n";
                $this_clashes .= "Individual rep edit clashes. ";
                $ms_change = 1;
                $ge_change = 1;
            }
        } else {
            # Same
            if ($prev_mysociety || $prev_new) {
                #print "Both made same change\n" if $verbose > 2;
                #print "\tMS change: $prev_mysociety\n" if $verbose > 2;
                #print "\tGE change: $prev_new\n" if $verbose > 2;;
            }
        }
    }

    #################################################################
    # Make modifications to raw input table in database

    if (($ge_change && $ms_add_del) || ($ms_change && $ge_add_del)) {
        $this_clashes .= "Add/del by one, small mods by other. ";
    }

    if ($ge_change or $ge_add_del) {
        print $out;

        # Count clashes
        if ($this_clashes) {
            $clashes_count++;
            print "CLASH REASONS: " . $this_clashes . "\n";
        }       
        
        # Edit the data
        print "Modifying\n";

        # First a user "import" load the full new data for later reference (we
        # go back to this position when we next do a load)
        mySociety::CouncilMatch::edit_raw_data($council_id, $councils->{$council_id}->{govevalname},
            $area_id_data->{$council_id}->{type}, $area_id_data->{$council_id}->{ons_code},
            [values %$reps_new_import], "import");

        # Then on top of that apply the merges
        mySociety::CouncilMatch::edit_raw_data($council_id, $councils->{$council_id}->{govevalname},
            $area_id_data->{$council_id}->{type}, $area_id_data->{$council_id}->{ons_code},
            [values %$reps_merged], "merge");

    } else {
        die "Unexpected clashes when no GE changes:\n$this_clashes" if $this_clashes;
        print $out;
        print "Nothing to do\n";
    }
}

print "-" x 70 . "\n";
print "All done.  $clashes_count/$councils_count clash a bit\n";

$m_dbh->commit();
$d_dbh->commit();
$m_dbh->disconnect();
$d_dbh->disconnect();

