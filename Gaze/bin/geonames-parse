#!/usr/bin/perl -w
#
# geonames-parse:
# Parse GEOnet Names Server data from http://earth-info.nga.mil/gns/html/
#
# Copyright (c) 2005 Chris Lightfoot. All rights reserved.
# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
#

my $rcsid = ''; $rcsid .= '$Id: geonames-parse,v 1.3 2005-07-08 09:47:56 chris Exp $';

use strict;
require 5.8.0;

use IO::File;
use POSIX qw(acos);
use Text::CSV;

# Grab the list of "ADM1" administrative regions.
open(ADM1, "/tmp/geonames/_fips_adm1_code_def_2.txt");
binmode(ADM1, ":bytes");
<ADM1>; # header

my %ADM1_name;

while (my $line = <ADM1>) {
    chomp($line);
    my ($cc, $adm1, $name) = split(/\t/, $line);
    if (!utf8::decode($name)) {
        die "name \"$name\" for ADM1 $cc/$adm1 is not valid UTF-8";
    }
    $ADM1_name{$cc}->{$adm1} = $name;
}

close(ADM1);

binmode(STDOUT, ":utf8");

# Defined in http://earth-info.nga.mil/gns/html/gis.html
my @fieldnames = qw(
        RC UFI UNI LAT LONG DMS_LAT DMS_LONG UTM JOG FC DSG PC CC1 ADM1 ADM2
        DIM CC2 NT LC SHORT_FORM GENERIC SORT_NAME FULL_NAME FULL_NAME_ND
        MOD_DATE
    );

my %data_by_UFI;

my %names_by_UFI;
my %seen_UFI;

my %UFI_by_name;
my %ambiguous_names;

sub trim ($) {
    my $x = shift;
    $x =~ s/^\s+//;
    $x =~ s/\s+$//;
    return $x;
}

my %name_type_exists;
my %name_types;

# Smaller numbers mean higher preference. These values are used: (a) to select
# the effective type of a name which is stated under more than one type; (b) to
# select the preferred "primary" name where names of several types are
# available.
my %name_type_preference = (
        C => 0,         # Conventional
        N => 1,         # Native
        V => 2,         # Variant or alternate
        D => 10         # Not verified
    );

# Hash which maps UFI to reference to hash of name to name-type.
my %UFI_name;

<STDIN>;    # Skip header

# Each record describes a name and a feature. Each feature may have multiple
# names.
while (my $line = <STDIN>) {
    chomp($line);
    my @fields = split(/\t/, $line);
    my %fields = map { $_ => trim(shift(@fields)) } @fieldnames;

    # The only records we grab are those which describe populated places.
    next if ($fields{FC} ne 'P');

    # Check that the various names are valid UTF-8. Experiments suggest that
    # SORT_NAME and FULL_NAME_ND won't be (though I'm not sure how they are
    # actually coded), but happily we don't need those.
    foreach (qw(SHORT_FORM GENERIC FULL_NAME)) {
        if (!utf8::decode($fields{$_})) {
            die "$_ name \"$fields{$_}\" for UFI $fields{UFI} UNI $fields{UNI} is not valid UTF-8";
        }
    }

    my $name = $fields{FULL_NAME};
    next if ($name =~ m#\(\(.*\)\)#);
    die if ($name eq '');
    
    my $ufi = $fields{UFI};
    $UFI_name{$ufi} ||= { };
    my $name_type = $fields{NT};

    $data_by_UFI{$fields{UFI}} = \%fields;

    if (exists($UFI_name{$ufi}->{$name})) {
        warn "#$ufi already has name '$name', type $UFI_name{$ufi}->{$name}\n";
        $UFI_name{$ufi}->{$name} = $name_type
            if ($name_type_preference{$name_type} < $name_type_preference{$UFI_name{$ufi}->{$name}});
    } else {
        $UFI_name{$ufi}->{$name} = $name_type;
    }

    $name_type_exists{$name_type} ||= 1;
    ++$name_types{$name_type}->{$fields{NT}};

    if (exists($seen_UFI{$fields{UFI}})) {
        next;
    }
    $seen_UFI{$fields{UFI}} = 1;

    if (exists($UFI_by_name{$name}) && @{$UFI_by_name{$name}} && grep { $ufi != $_ } @{$UFI_by_name{$name}}) {
        $ambiguous_names{$name} = 1;
#        warn "ambiguous: $name\n";
    }
    push(@{$UFI_by_name{$name}}, $ufi);
}

my %UFI_by_primary_name;
my %primary_name_by_UFI;
my %ambiguous_primary_names;

# Identify the primary name for each place.
foreach my $ufi (keys(%UFI_name)) {
    my $nn = $UFI_name{$ufi};
    my @names = sort { $name_type_preference{$nn->{$a}} <=> $name_type_preference{$nn->{$b}} } keys(%$nn);
    my $primary_name = $names[0];

    $primary_name_by_UFI{$ufi} = $primary_name;
    push(@{$UFI_by_primary_name{lc($primary_name)}}, $ufi);
    if (@{$UFI_by_primary_name{lc($primary_name)}} > 1) {
        $ambiguous_primary_names{lc($primary_name)} ||= 1;
    }
}

my @UFIs_in_lat_order = sort { $data_by_UFI{$a}->{LAT} <=> $data_by_UFI{$b}->{LAT} } keys(%data_by_UFI);
use constant R_e => 6372.8; # radius of the earth in km
use constant M_PI => 3.141592654;

sub rad ($) {
    return M_PI * $_[0] / 180.;
}

sub deg ($) {
    return 180. * $_[0] / M_PI;
}

# distance LAT1 LON2 LAT2 LON2
# Return the great-circle distance between (LAT1, LON1) and (LAT2, LON2).
sub distance ($$$$) {
    my ($lat1, $lon1, $lat2, $lon2) = map { rad($_) } @_;
    return R_e * acos(sin($lat1) * sin($lat2) + cos($lat1) * cos($lat2) * cos($lon1 - $lon2));
}

# find_places_near LAT LON DISTANCE
# Return in list context [UFI, distance] of places within DISTANCE km of (LAT,
# LON).
sub find_places_near ($$$) {
    my ($lat, $lon, $dist) = @_;
    my ($lat_l, $lat_h) = ($lat - deg($dist / R_e), $lat + deg($dist / R_e));
    my ($ind_l, $ind_h);    # Bracketing indexes for search in list of UFIs

    # Find low limit of UFIs.
    my ($l, $h) = (0, $#UFIs_in_lat_order);
    while ($h > $l + 1) {
        my $a = int(($h + $l) / 2);
        my $ufi = $UFIs_in_lat_order[$a];
        my $ll = $data_by_UFI{$ufi}->{LAT};
        if ($ll < $lat_l) {
            $l = $a;
        } else {
            $h = $a;
        }
    }
    $ind_l = $l;

    ($l, $h) = (0, $#UFIs_in_lat_order);
    while ($h > $l + 1) {
        my $a = int(($h + $l) / 2);
        my $ufi = $UFIs_in_lat_order[$a];
        my $ll = $data_by_UFI{$ufi}->{LAT};
        if ($ll > $lat_h) {
            $h = $a;
        } else {
            $l = $a;
        }
    }
    $ind_h = $h;

#print "lat = ", $lat, " l = $ind_l, h = $ind_h, lat_lo = $data_by_UFI{$UFIs_in_lat_order[$ind_l]}->{LAT} (vs $lat_l), lat_hi = $data_by_UFI{$UFIs_in_lat_order[$ind_h]}->{LAT} (vs $lat_h)\n";

    return grep { $_->[1] < $dist } map { [$_, distance($lat, $lon, $data_by_UFI{$_}->{LAT}, $data_by_UFI{$_}->{LONG})] } @UFIs_in_lat_order[$ind_l .. $ind_h];
}

# Decide on qualifiers for ambiguous names.
foreach my $primary_name (sort keys %ambiguous_primary_names) {
    print "$primary_name:\n";
    
    my %adm1s;
    map { ++$adm1s{$data_by_UFI{$_}->{ADM1}} } @{$UFI_by_primary_name{$primary_name}};
    foreach my $ufi (@{$UFI_by_primary_name{$primary_name}}) {
        my $place = $data_by_UFI{$ufi};
        print "    $ufi PC=$place->{PC} $place->{DIM} $place->{FC} ($place->{LAT}, $place->{LONG})\n";
        print "      - ADM1 = $place->{ADM1}; ADM2 = $place->{ADM2}\n";

        print "      - distance to other places of same name:";
        my $mindist = 1e6;
        foreach my $ufi2 (@{$UFI_by_primary_name{$primary_name}}) {
            next if ($ufi == $ufi2);
            my $d = distance($data_by_UFI{$ufi}->{LAT}, $data_by_UFI{$ufi}->{LONG}, $data_by_UFI{$ufi2}->{LAT}, $data_by_UFI{$ufi2}->{LONG});
            print " ${d}km";
            $mindist = $d if ($d < $mindist);
        }
        print "\n";

        # ADM1 code of '00' means "general", so not useful for identifying
        # places. Therfore, we don't try to disambiguate place names if any of
        # the variants has a '00' ADM1.
        if (!exists($adm1s{'00'})) {
            if ($adm1s{$place->{ADM1}} == 1) {
                print "      - describe as 'in $ADM1_name{$place->{CC1}}->{$place->{ADM1}}'\n";
                next
            } else {
                print "      - shares $ADM1_name{$place->{CC1}}->{$place->{ADM1}} with ", $adm1s{$place->{ADM1}} - 1, " other places of the same name\n";
            }
        }

        $mindist = 10 if ($mindist < 10);
#        $mindist = 10 if ($mindist > 10);
        my @nearby = sort { $a->[1] <=> $b->[1] }
                        grep {
                            # Mustn't identify a place as being near another
                            # ambiguously named place...
                            !exists($ambiguous_primary_names{lc($primary_name_by_UFI{$_->[0]})})
                            # or as near itself.
                            && $_->[0] ne $ufi
                        } find_places_near($place->{LAT}, $place->{LONG}, $mindist / 2);
        my $n = $#nearby;
        $n = 2 if ($n > 2);
        @nearby = @nearby[0 .. $n];
        print "      - nearby: ", join(", ", map { "$_->[0] PC=$data_by_UFI{$_->[0]}->{PC} $data_by_UFI{$_->[0]}->{DIM} $primary_name_by_UFI{$_->[0]} ($_->[1]km)" } @nearby), "\n\n";

        # 
        
#        print GP "set label '$full_name ($place->{FC})' at $place->{LONG}, $place->{LAT} point pt 1\n";
    }
}

