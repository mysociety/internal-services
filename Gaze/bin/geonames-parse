#!/usr/bin/perl -w -I../perllib -I../../../perllib
#
# geonames-parse:
# Parse GEOnet Names Server data from http://earth-info.nga.mil/gns/html/
#
# Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: geonames-parse,v 1.6 2005-07-15 12:12:27 chris Exp $';

use strict;
require 5.8.0;

use IO::File;
use POSIX qw(acos);
use Text::CSV;

#use mySociety::Config;
use mySociety::DBHandle qw(dbh);

use Gaze;

mySociety::DBHandle::configure(Name => 'gaze', User => 'gaze');

# strip_punctuation NAME
# Remove punctuation from NAME. This is used to broaden our search for
# ambiguous names; we want to treat, e.g., "St Peters" as ambiguous with "St.
# Peter's", or "Le Petit-Paris" with "Le Petit Paris".
sub strip_punctuation ($) {
    my $t = shift;
    $t =~ s#[^[:alpha:]]##g;
    return $t;
}

# Grab the list of "ADM1" administrative regions.
open(ADM1, "/tmp/geonames/_fips_adm1_code_def_2.txt");
binmode(ADM1, ":bytes");
<ADM1>; # header

my %ADM1_name;

while (my $line = <ADM1>) {
    chomp($line);
    my ($cc, $adm1, $name) = split(/\t/, $line);
    if (!utf8::decode($name)) {
        die "name \"$name\" for ADM1 $cc/$adm1 is not valid UTF-8";
    }
    $ADM1_name{$cc}->{$adm1} = $name;
}

close(ADM1);

binmode(STDOUT, ":utf8");

# Defined in http://earth-info.nga.mil/gns/html/gis.html
my @fieldnames = qw(
        RC UFI UNI LAT LONG DMS_LAT DMS_LONG UTM JOG FC DSG PC CC1 ADM1 ADM2
        DIM CC2 NT LC SHORT_FORM GENERIC SORT_NAME FULL_NAME FULL_NAME_ND
        MOD_DATE
    );

my %data_by_UFI;

my %names_by_UFI;
my %seen_UFI;

sub trim ($) {
    my $x = shift;
    $x =~ s/^\s+//;
    $x =~ s/\s+$//;
    return $x;
}

my %name_type_exists;
my %name_types;

# Smaller numbers mean higher preference. These values are used: (a) to select
# the effective type of a name which is stated under more than one type; (b) to
# select the preferred "primary" name where names of several types are
# available.
my %name_type_preference = (
        C => 0,         # Conventional
        N => 1,         # Native
        V => 2,         # Variant or alternate
        D => 10         # Not verified
    );

# Hash which maps UFI to reference to hash of name to name-type and UNI.
my %UFI_name;

<STDIN>;    # Skip header

# Each record describes a name and a feature. Each feature may have multiple
# names.
my $nf = 0;
while (my $line = <STDIN>) {
    print STDERR "\rReading names: ", ++$nf;
    chomp($line);
    my @fields = split(/\t/, $line);
    my %fields = map { $_ => trim(shift(@fields)) } @fieldnames;

    # The only records we grab are those which describe populated places.
    next if ($fields{FC} ne 'P');

    # Check that the various names are valid UTF-8. Experiments suggest that
    # SORT_NAME and FULL_NAME_ND won't be (though I'm not sure how they are
    # actually coded), but happily we don't need those.
    foreach (qw(SHORT_FORM GENERIC FULL_NAME)) {
        if (!utf8::decode($fields{$_})) {
            die "$_ name \"$fields{$_}\" for UFI $fields{UFI} UNI $fields{UNI} is not valid UTF-8";
        }
    }

    my $name = $fields{FULL_NAME};
    next if ($name =~ m#\(\(.*\)\)#);
    die if ($name eq '');

    # Change index reading order to normal reading order.
    if ($name =~ /,/) {
        print STDERR "$name -> ";
        $name = join(' ', reverse(split(/,\s*/, $name)));
        print STDERR "$name\n";
    }
    
    my $ufi = $fields{UFI};
    my $uni = $fields{UNI};
    $UFI_name{$ufi} ||= { };
    my $name_type = $fields{NT};

    if (!exists($data_by_UFI{$ufi})) {
        $data_by_UFI{$ufi} = \%fields;
        $fields{PC} = undef if ($fields{PC} eq '');
        dbh()->do('insert into feature (ufi, country, lat, lon, populated_place_classification) values (?, ?, ?, ?, ?)', {}, $ufi, map { $fields{$_} } qw(CC1 LAT LONG PC));
    }

    if (exists($UFI_name{$ufi}->{$name})) {
        warn "#$ufi already has name '$name', type $UFI_name{$ufi}->{$name}->[0]\n";
        $UFI_name{$ufi}->{$name} = [$name_type, $uni]
            if ($name_type_preference{$name_type} < $name_type_preference{$UFI_name{$ufi}->{$name}->[0]});
    } else {
        $UFI_name{$ufi}->{$name} = [$name_type, $uni];
    }

    $name_type_exists{$name_type} ||= 1;
    ++$name_types{$name_type}->{$fields{NT}};

    $seen_UFI{$fields{UFI}} = 1;
}
print STDERR "\n";

my %UFI_by_primary_name;
my %primary_name_by_UFI;
my %ambiguous_primary_names;

# Identify the primary name for each place and write all the names into the
# database.
my $np = 0;
foreach my $ufi (keys(%UFI_name)) {
    print STDERR "\rDeriving primary names: ", ++$np, "/", scalar(keys(%UFI_name));
    my $nn = $UFI_name{$ufi};
    my @names = sort { $name_type_preference{$nn->{$a}->[0]} <=> $name_type_preference{$nn->{$b}->[0]} } keys(%$nn);
    my $primary_name = $names[0];

    my $f = 1;
    foreach (@names) {
        my ($nt, $uni) = @{$nn->{$_}};
        dbh()->do('insert into name (uni, ufi, is_primary, full_name, name_type) values (?, ?, ?, ?, ?)', {}, $uni, $ufi, $f ? 'true' : 'false', $_, $nt);
        $f = 0;

        my $h = Gaze::split_name_parts($_);
        foreach my $part (keys %$h) {
            dbh()->do('insert into name_part (uni, namepart, count) values (?, ?, ?)', {}, $uni, $part, $h->{$part});
        }
    }

    $primary_name_by_UFI{$ufi} = $primary_name;
    my $s = lc(strip_punctuation($primary_name));
    push(@{$UFI_by_primary_name{$s}}, $ufi);
    $ambiguous_primary_names{$s} ||= 1
        if (@{$UFI_by_primary_name{$s}} > 1);
}
print STDERR "\n";

my @UFIs_in_lat_order = sort { $data_by_UFI{$a}->{LAT} <=> $data_by_UFI{$b}->{LAT} } keys(%data_by_UFI);
use constant R_e => 6372.8; # radius of the earth in km
use constant M_PI => 3.141592654;

sub rad ($) {
    return M_PI * $_[0] / 180.;
}

sub deg ($) {
    return 180. * $_[0] / M_PI;
}

# distance LAT1 LON2 LAT2 LON2
# Return the great-circle distance between (LAT1, LON1) and (LAT2, LON2).
sub distance ($$$$) {
    my ($lat1, $lon1, $lat2, $lon2) = map { rad($_) } @_;
    return R_e * acos(sin($lat1) * sin($lat2) + cos($lat1) * cos($lat2) * cos($lon1 - $lon2));
}

# find_places_near LAT LON DISTANCE
# Return in list context [UFI, distance] of places within DISTANCE km of (LAT,
# LON).
sub find_places_near ($$$) {
    my ($lat, $lon, $dist) = @_;
    my ($lat_l, $lat_h) = ($lat - deg($dist / R_e), $lat + deg($dist / R_e));
    my ($ind_l, $ind_h);    # Bracketing indexes for search in list of UFIs

    # Find low limit of UFIs.
    my ($l, $h) = (0, $#UFIs_in_lat_order);
    while ($h > $l + 1) {
        my $a = int(($h + $l) / 2);
        my $ufi = $UFIs_in_lat_order[$a];
        my $ll = $data_by_UFI{$ufi}->{LAT};
        if ($ll < $lat_l) {
            $l = $a;
        } else {
            $h = $a;
        }
    }
    $ind_l = $l;

    ($l, $h) = (0, $#UFIs_in_lat_order);
    while ($h > $l + 1) {
        my $a = int(($h + $l) / 2);
        my $ufi = $UFIs_in_lat_order[$a];
        my $ll = $data_by_UFI{$ufi}->{LAT};
        if ($ll > $lat_h) {
            $h = $a;
        } else {
            $l = $a;
        }
    }
    $ind_h = $h;

    return grep { $_->[1] < $dist } map { [$_, distance($lat, $lon, $data_by_UFI{$_}->{LAT}, $data_by_UFI{$_}->{LONG})] } @UFIs_in_lat_order[$ind_l .. $ind_h];
}

# Decide on qualifiers for ambiguous names.
my $na = 0;
foreach my $primary_name (sort keys %ambiguous_primary_names) {
    print STDERR "Finding qualifiers for ambiguous names: ", ++$na, "/", scalar(keys(%ambiguous_primary_names));
    my %adm1s;
    map { ++$adm1s{$data_by_UFI{$_}->{ADM1}} } @{$UFI_by_primary_name{$primary_name}};
    foreach my $ufi (@{$UFI_by_primary_name{$primary_name}}) {
        my $place = $data_by_UFI{$ufi};

        # Find distance to places of the same name
        my $mindist = 1e6;
        foreach my $ufi2 (@{$UFI_by_primary_name{$primary_name}}) {
            next if ($ufi == $ufi2);
            my $d = distance($data_by_UFI{$ufi}->{LAT}, $data_by_UFI{$ufi}->{LONG}, $data_by_UFI{$ufi2}->{LAT}, $data_by_UFI{$ufi2}->{LONG});
            $mindist = $d if ($d < $mindist);
        }
        print "\n";

        # ADM1 code of '00' means "general", so not useful for identifying
        # places. Therfore, we don't try to disambiguate place names by
        # enclosing administrative region if any of the variants has a '00'
        # ADM1.
        if (!exists($adm1s{'00'}) && $adm1s{$place->{ADM1}} == 1) {
            # None of the places has a 00 ADM1, and this is the only such place
            # which is in this administrative division.
            dbh()->do("update feature set qualifier_type = 'in', qualifier = ? where ufi = ?", {}, $ADM1_name{$place->{CC1}}->{$place->{ADM1}}, $ufi);
            next;
        }

        $mindist = 10 if ($mindist < 10);
#        $mindist = 10 if ($mindist > 10);
        my @nearby = sort { $a->[1] <=> $b->[1] }
                        grep {
                            # Mustn't identify a place as being near another
                            # ambiguously named place...
                            !exists($ambiguous_primary_names{lc($primary_name_by_UFI{$_->[0]})})
                            # or as near itself.
                            && $_->[0] ne $ufi
                        } find_places_near($place->{LAT}, $place->{LONG}, $mindist / 2);
        my $n = $#nearby;
        $n = 2 if ($n > 2);
        @nearby = @nearby[0 .. $n];

        dbh()->do("update feature set qualifier_type = 'near', qualifier = ? where ufi = ?", {}, join(", ", map { $primary_name_by_UFI{$_->[0]} } @nearby), $ufi);
    }
}

dbh()->commit();
